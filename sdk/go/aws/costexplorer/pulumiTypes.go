// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package costexplorer

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type CostCategoryRule struct {
	// Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
	InheritedValue *CostCategoryRuleInheritedValue `pulumi:"inheritedValue"`
	// Configuration block for the `Expression` object used to categorize costs. See below.
	Rule *CostCategoryRuleRule `pulumi:"rule"`
	// Parameter type.
	Type *string `pulumi:"type"`
	// Default value for the cost category.
	Value *string `pulumi:"value"`
}

// CostCategoryRuleInput is an input type that accepts CostCategoryRuleArgs and CostCategoryRuleOutput values.
// You can construct a concrete instance of `CostCategoryRuleInput` via:
//
//          CostCategoryRuleArgs{...}
type CostCategoryRuleInput interface {
	pulumi.Input

	ToCostCategoryRuleOutput() CostCategoryRuleOutput
	ToCostCategoryRuleOutputWithContext(context.Context) CostCategoryRuleOutput
}

type CostCategoryRuleArgs struct {
	// Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
	InheritedValue CostCategoryRuleInheritedValuePtrInput `pulumi:"inheritedValue"`
	// Configuration block for the `Expression` object used to categorize costs. See below.
	Rule CostCategoryRuleRulePtrInput `pulumi:"rule"`
	// Parameter type.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Default value for the cost category.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (CostCategoryRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRule)(nil)).Elem()
}

func (i CostCategoryRuleArgs) ToCostCategoryRuleOutput() CostCategoryRuleOutput {
	return i.ToCostCategoryRuleOutputWithContext(context.Background())
}

func (i CostCategoryRuleArgs) ToCostCategoryRuleOutputWithContext(ctx context.Context) CostCategoryRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleOutput)
}

// CostCategoryRuleArrayInput is an input type that accepts CostCategoryRuleArray and CostCategoryRuleArrayOutput values.
// You can construct a concrete instance of `CostCategoryRuleArrayInput` via:
//
//          CostCategoryRuleArray{ CostCategoryRuleArgs{...} }
type CostCategoryRuleArrayInput interface {
	pulumi.Input

	ToCostCategoryRuleArrayOutput() CostCategoryRuleArrayOutput
	ToCostCategoryRuleArrayOutputWithContext(context.Context) CostCategoryRuleArrayOutput
}

type CostCategoryRuleArray []CostCategoryRuleInput

func (CostCategoryRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CostCategoryRule)(nil)).Elem()
}

func (i CostCategoryRuleArray) ToCostCategoryRuleArrayOutput() CostCategoryRuleArrayOutput {
	return i.ToCostCategoryRuleArrayOutputWithContext(context.Background())
}

func (i CostCategoryRuleArray) ToCostCategoryRuleArrayOutputWithContext(ctx context.Context) CostCategoryRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleArrayOutput)
}

type CostCategoryRuleOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRule)(nil)).Elem()
}

func (o CostCategoryRuleOutput) ToCostCategoryRuleOutput() CostCategoryRuleOutput {
	return o
}

func (o CostCategoryRuleOutput) ToCostCategoryRuleOutputWithContext(ctx context.Context) CostCategoryRuleOutput {
	return o
}

// Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
func (o CostCategoryRuleOutput) InheritedValue() CostCategoryRuleInheritedValuePtrOutput {
	return o.ApplyT(func(v CostCategoryRule) *CostCategoryRuleInheritedValue { return v.InheritedValue }).(CostCategoryRuleInheritedValuePtrOutput)
}

// Configuration block for the `Expression` object used to categorize costs. See below.
func (o CostCategoryRuleOutput) Rule() CostCategoryRuleRulePtrOutput {
	return o.ApplyT(func(v CostCategoryRule) *CostCategoryRuleRule { return v.Rule }).(CostCategoryRuleRulePtrOutput)
}

// Parameter type.
func (o CostCategoryRuleOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRule) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Default value for the cost category.
func (o CostCategoryRuleOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRule) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type CostCategoryRuleArrayOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CostCategoryRule)(nil)).Elem()
}

func (o CostCategoryRuleArrayOutput) ToCostCategoryRuleArrayOutput() CostCategoryRuleArrayOutput {
	return o
}

func (o CostCategoryRuleArrayOutput) ToCostCategoryRuleArrayOutputWithContext(ctx context.Context) CostCategoryRuleArrayOutput {
	return o
}

func (o CostCategoryRuleArrayOutput) Index(i pulumi.IntInput) CostCategoryRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CostCategoryRule {
		return vs[0].([]CostCategoryRule)[vs[1].(int)]
	}).(CostCategoryRuleOutput)
}

type CostCategoryRuleInheritedValue struct {
	// Key to extract cost category values.
	DimensionKey *string `pulumi:"dimensionKey"`
	// Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
	DimensionName *string `pulumi:"dimensionName"`
}

// CostCategoryRuleInheritedValueInput is an input type that accepts CostCategoryRuleInheritedValueArgs and CostCategoryRuleInheritedValueOutput values.
// You can construct a concrete instance of `CostCategoryRuleInheritedValueInput` via:
//
//          CostCategoryRuleInheritedValueArgs{...}
type CostCategoryRuleInheritedValueInput interface {
	pulumi.Input

	ToCostCategoryRuleInheritedValueOutput() CostCategoryRuleInheritedValueOutput
	ToCostCategoryRuleInheritedValueOutputWithContext(context.Context) CostCategoryRuleInheritedValueOutput
}

type CostCategoryRuleInheritedValueArgs struct {
	// Key to extract cost category values.
	DimensionKey pulumi.StringPtrInput `pulumi:"dimensionKey"`
	// Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
	DimensionName pulumi.StringPtrInput `pulumi:"dimensionName"`
}

func (CostCategoryRuleInheritedValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleInheritedValue)(nil)).Elem()
}

func (i CostCategoryRuleInheritedValueArgs) ToCostCategoryRuleInheritedValueOutput() CostCategoryRuleInheritedValueOutput {
	return i.ToCostCategoryRuleInheritedValueOutputWithContext(context.Background())
}

func (i CostCategoryRuleInheritedValueArgs) ToCostCategoryRuleInheritedValueOutputWithContext(ctx context.Context) CostCategoryRuleInheritedValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleInheritedValueOutput)
}

func (i CostCategoryRuleInheritedValueArgs) ToCostCategoryRuleInheritedValuePtrOutput() CostCategoryRuleInheritedValuePtrOutput {
	return i.ToCostCategoryRuleInheritedValuePtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleInheritedValueArgs) ToCostCategoryRuleInheritedValuePtrOutputWithContext(ctx context.Context) CostCategoryRuleInheritedValuePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleInheritedValueOutput).ToCostCategoryRuleInheritedValuePtrOutputWithContext(ctx)
}

// CostCategoryRuleInheritedValuePtrInput is an input type that accepts CostCategoryRuleInheritedValueArgs, CostCategoryRuleInheritedValuePtr and CostCategoryRuleInheritedValuePtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleInheritedValuePtrInput` via:
//
//          CostCategoryRuleInheritedValueArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleInheritedValuePtrInput interface {
	pulumi.Input

	ToCostCategoryRuleInheritedValuePtrOutput() CostCategoryRuleInheritedValuePtrOutput
	ToCostCategoryRuleInheritedValuePtrOutputWithContext(context.Context) CostCategoryRuleInheritedValuePtrOutput
}

type costCategoryRuleInheritedValuePtrType CostCategoryRuleInheritedValueArgs

func CostCategoryRuleInheritedValuePtr(v *CostCategoryRuleInheritedValueArgs) CostCategoryRuleInheritedValuePtrInput {
	return (*costCategoryRuleInheritedValuePtrType)(v)
}

func (*costCategoryRuleInheritedValuePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleInheritedValue)(nil)).Elem()
}

func (i *costCategoryRuleInheritedValuePtrType) ToCostCategoryRuleInheritedValuePtrOutput() CostCategoryRuleInheritedValuePtrOutput {
	return i.ToCostCategoryRuleInheritedValuePtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleInheritedValuePtrType) ToCostCategoryRuleInheritedValuePtrOutputWithContext(ctx context.Context) CostCategoryRuleInheritedValuePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleInheritedValuePtrOutput)
}

type CostCategoryRuleInheritedValueOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleInheritedValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleInheritedValue)(nil)).Elem()
}

func (o CostCategoryRuleInheritedValueOutput) ToCostCategoryRuleInheritedValueOutput() CostCategoryRuleInheritedValueOutput {
	return o
}

func (o CostCategoryRuleInheritedValueOutput) ToCostCategoryRuleInheritedValueOutputWithContext(ctx context.Context) CostCategoryRuleInheritedValueOutput {
	return o
}

func (o CostCategoryRuleInheritedValueOutput) ToCostCategoryRuleInheritedValuePtrOutput() CostCategoryRuleInheritedValuePtrOutput {
	return o.ToCostCategoryRuleInheritedValuePtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleInheritedValueOutput) ToCostCategoryRuleInheritedValuePtrOutputWithContext(ctx context.Context) CostCategoryRuleInheritedValuePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleInheritedValue) *CostCategoryRuleInheritedValue {
		return &v
	}).(CostCategoryRuleInheritedValuePtrOutput)
}

// Key to extract cost category values.
func (o CostCategoryRuleInheritedValueOutput) DimensionKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleInheritedValue) *string { return v.DimensionKey }).(pulumi.StringPtrOutput)
}

// Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
func (o CostCategoryRuleInheritedValueOutput) DimensionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleInheritedValue) *string { return v.DimensionName }).(pulumi.StringPtrOutput)
}

type CostCategoryRuleInheritedValuePtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleInheritedValuePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleInheritedValue)(nil)).Elem()
}

func (o CostCategoryRuleInheritedValuePtrOutput) ToCostCategoryRuleInheritedValuePtrOutput() CostCategoryRuleInheritedValuePtrOutput {
	return o
}

func (o CostCategoryRuleInheritedValuePtrOutput) ToCostCategoryRuleInheritedValuePtrOutputWithContext(ctx context.Context) CostCategoryRuleInheritedValuePtrOutput {
	return o
}

func (o CostCategoryRuleInheritedValuePtrOutput) Elem() CostCategoryRuleInheritedValueOutput {
	return o.ApplyT(func(v *CostCategoryRuleInheritedValue) CostCategoryRuleInheritedValue {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleInheritedValue
		return ret
	}).(CostCategoryRuleInheritedValueOutput)
}

// Key to extract cost category values.
func (o CostCategoryRuleInheritedValuePtrOutput) DimensionKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleInheritedValue) *string {
		if v == nil {
			return nil
		}
		return v.DimensionKey
	}).(pulumi.StringPtrOutput)
}

// Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
func (o CostCategoryRuleInheritedValuePtrOutput) DimensionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleInheritedValue) *string {
		if v == nil {
			return nil
		}
		return v.DimensionName
	}).(pulumi.StringPtrOutput)
}

type CostCategoryRuleRule struct {
	// Return results that match both `Dimension` objects.
	Ands []CostCategoryRuleRuleAnd `pulumi:"ands"`
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory *CostCategoryRuleRuleCostCategory `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension *CostCategoryRuleRuleDimension `pulumi:"dimension"`
	// Return results that match both `Dimension` object.
	Not *CostCategoryRuleRuleNot `pulumi:"not"`
	// Return results that match both `Dimension` object.
	Ors  []CostCategoryRuleRuleOr  `pulumi:"ors"`
	Tags *CostCategoryRuleRuleTags `pulumi:"tags"`
}

// CostCategoryRuleRuleInput is an input type that accepts CostCategoryRuleRuleArgs and CostCategoryRuleRuleOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleInput` via:
//
//          CostCategoryRuleRuleArgs{...}
type CostCategoryRuleRuleInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleOutput() CostCategoryRuleRuleOutput
	ToCostCategoryRuleRuleOutputWithContext(context.Context) CostCategoryRuleRuleOutput
}

type CostCategoryRuleRuleArgs struct {
	// Return results that match both `Dimension` objects.
	Ands CostCategoryRuleRuleAndArrayInput `pulumi:"ands"`
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory CostCategoryRuleRuleCostCategoryPtrInput `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension CostCategoryRuleRuleDimensionPtrInput `pulumi:"dimension"`
	// Return results that match both `Dimension` object.
	Not CostCategoryRuleRuleNotPtrInput `pulumi:"not"`
	// Return results that match both `Dimension` object.
	Ors  CostCategoryRuleRuleOrArrayInput `pulumi:"ors"`
	Tags CostCategoryRuleRuleTagsPtrInput `pulumi:"tags"`
}

func (CostCategoryRuleRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRule)(nil)).Elem()
}

func (i CostCategoryRuleRuleArgs) ToCostCategoryRuleRuleOutput() CostCategoryRuleRuleOutput {
	return i.ToCostCategoryRuleRuleOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleArgs) ToCostCategoryRuleRuleOutputWithContext(ctx context.Context) CostCategoryRuleRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOutput)
}

func (i CostCategoryRuleRuleArgs) ToCostCategoryRuleRulePtrOutput() CostCategoryRuleRulePtrOutput {
	return i.ToCostCategoryRuleRulePtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleArgs) ToCostCategoryRuleRulePtrOutputWithContext(ctx context.Context) CostCategoryRuleRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOutput).ToCostCategoryRuleRulePtrOutputWithContext(ctx)
}

// CostCategoryRuleRulePtrInput is an input type that accepts CostCategoryRuleRuleArgs, CostCategoryRuleRulePtr and CostCategoryRuleRulePtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRulePtrInput` via:
//
//          CostCategoryRuleRuleArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRulePtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRulePtrOutput() CostCategoryRuleRulePtrOutput
	ToCostCategoryRuleRulePtrOutputWithContext(context.Context) CostCategoryRuleRulePtrOutput
}

type costCategoryRuleRulePtrType CostCategoryRuleRuleArgs

func CostCategoryRuleRulePtr(v *CostCategoryRuleRuleArgs) CostCategoryRuleRulePtrInput {
	return (*costCategoryRuleRulePtrType)(v)
}

func (*costCategoryRuleRulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRule)(nil)).Elem()
}

func (i *costCategoryRuleRulePtrType) ToCostCategoryRuleRulePtrOutput() CostCategoryRuleRulePtrOutput {
	return i.ToCostCategoryRuleRulePtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRulePtrType) ToCostCategoryRuleRulePtrOutputWithContext(ctx context.Context) CostCategoryRuleRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRulePtrOutput)
}

type CostCategoryRuleRuleOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRule)(nil)).Elem()
}

func (o CostCategoryRuleRuleOutput) ToCostCategoryRuleRuleOutput() CostCategoryRuleRuleOutput {
	return o
}

func (o CostCategoryRuleRuleOutput) ToCostCategoryRuleRuleOutputWithContext(ctx context.Context) CostCategoryRuleRuleOutput {
	return o
}

func (o CostCategoryRuleRuleOutput) ToCostCategoryRuleRulePtrOutput() CostCategoryRuleRulePtrOutput {
	return o.ToCostCategoryRuleRulePtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleOutput) ToCostCategoryRuleRulePtrOutputWithContext(ctx context.Context) CostCategoryRuleRulePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRule) *CostCategoryRuleRule {
		return &v
	}).(CostCategoryRuleRulePtrOutput)
}

// Return results that match both `Dimension` objects.
func (o CostCategoryRuleRuleOutput) Ands() CostCategoryRuleRuleAndArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRule) []CostCategoryRuleRuleAnd { return v.Ands }).(CostCategoryRuleRuleAndArrayOutput)
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o CostCategoryRuleRuleOutput) CostCategory() CostCategoryRuleRuleCostCategoryPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRule) *CostCategoryRuleRuleCostCategory { return v.CostCategory }).(CostCategoryRuleRuleCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o CostCategoryRuleRuleOutput) Dimension() CostCategoryRuleRuleDimensionPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRule) *CostCategoryRuleRuleDimension { return v.Dimension }).(CostCategoryRuleRuleDimensionPtrOutput)
}

// Return results that match both `Dimension` object.
func (o CostCategoryRuleRuleOutput) Not() CostCategoryRuleRuleNotPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRule) *CostCategoryRuleRuleNot { return v.Not }).(CostCategoryRuleRuleNotPtrOutput)
}

// Return results that match both `Dimension` object.
func (o CostCategoryRuleRuleOutput) Ors() CostCategoryRuleRuleOrArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRule) []CostCategoryRuleRuleOr { return v.Ors }).(CostCategoryRuleRuleOrArrayOutput)
}

func (o CostCategoryRuleRuleOutput) Tags() CostCategoryRuleRuleTagsPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRule) *CostCategoryRuleRuleTags { return v.Tags }).(CostCategoryRuleRuleTagsPtrOutput)
}

type CostCategoryRuleRulePtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRule)(nil)).Elem()
}

func (o CostCategoryRuleRulePtrOutput) ToCostCategoryRuleRulePtrOutput() CostCategoryRuleRulePtrOutput {
	return o
}

func (o CostCategoryRuleRulePtrOutput) ToCostCategoryRuleRulePtrOutputWithContext(ctx context.Context) CostCategoryRuleRulePtrOutput {
	return o
}

func (o CostCategoryRuleRulePtrOutput) Elem() CostCategoryRuleRuleOutput {
	return o.ApplyT(func(v *CostCategoryRuleRule) CostCategoryRuleRule {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRule
		return ret
	}).(CostCategoryRuleRuleOutput)
}

// Return results that match both `Dimension` objects.
func (o CostCategoryRuleRulePtrOutput) Ands() CostCategoryRuleRuleAndArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRule) []CostCategoryRuleRuleAnd {
		if v == nil {
			return nil
		}
		return v.Ands
	}).(CostCategoryRuleRuleAndArrayOutput)
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o CostCategoryRuleRulePtrOutput) CostCategory() CostCategoryRuleRuleCostCategoryPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRule) *CostCategoryRuleRuleCostCategory {
		if v == nil {
			return nil
		}
		return v.CostCategory
	}).(CostCategoryRuleRuleCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o CostCategoryRuleRulePtrOutput) Dimension() CostCategoryRuleRuleDimensionPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRule) *CostCategoryRuleRuleDimension {
		if v == nil {
			return nil
		}
		return v.Dimension
	}).(CostCategoryRuleRuleDimensionPtrOutput)
}

// Return results that match both `Dimension` object.
func (o CostCategoryRuleRulePtrOutput) Not() CostCategoryRuleRuleNotPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRule) *CostCategoryRuleRuleNot {
		if v == nil {
			return nil
		}
		return v.Not
	}).(CostCategoryRuleRuleNotPtrOutput)
}

// Return results that match both `Dimension` object.
func (o CostCategoryRuleRulePtrOutput) Ors() CostCategoryRuleRuleOrArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRule) []CostCategoryRuleRuleOr {
		if v == nil {
			return nil
		}
		return v.Ors
	}).(CostCategoryRuleRuleOrArrayOutput)
}

func (o CostCategoryRuleRulePtrOutput) Tags() CostCategoryRuleRuleTagsPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRule) *CostCategoryRuleRuleTags {
		if v == nil {
			return nil
		}
		return v.Tags
	}).(CostCategoryRuleRuleTagsPtrOutput)
}

type CostCategoryRuleRuleAnd struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory *CostCategoryRuleRuleAndCostCategory `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension *CostCategoryRuleRuleAndDimension `pulumi:"dimension"`
	Tags      *CostCategoryRuleRuleAndTags      `pulumi:"tags"`
}

// CostCategoryRuleRuleAndInput is an input type that accepts CostCategoryRuleRuleAndArgs and CostCategoryRuleRuleAndOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleAndInput` via:
//
//          CostCategoryRuleRuleAndArgs{...}
type CostCategoryRuleRuleAndInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleAndOutput() CostCategoryRuleRuleAndOutput
	ToCostCategoryRuleRuleAndOutputWithContext(context.Context) CostCategoryRuleRuleAndOutput
}

type CostCategoryRuleRuleAndArgs struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory CostCategoryRuleRuleAndCostCategoryPtrInput `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension CostCategoryRuleRuleAndDimensionPtrInput `pulumi:"dimension"`
	Tags      CostCategoryRuleRuleAndTagsPtrInput      `pulumi:"tags"`
}

func (CostCategoryRuleRuleAndArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleAnd)(nil)).Elem()
}

func (i CostCategoryRuleRuleAndArgs) ToCostCategoryRuleRuleAndOutput() CostCategoryRuleRuleAndOutput {
	return i.ToCostCategoryRuleRuleAndOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleAndArgs) ToCostCategoryRuleRuleAndOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleAndOutput)
}

// CostCategoryRuleRuleAndArrayInput is an input type that accepts CostCategoryRuleRuleAndArray and CostCategoryRuleRuleAndArrayOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleAndArrayInput` via:
//
//          CostCategoryRuleRuleAndArray{ CostCategoryRuleRuleAndArgs{...} }
type CostCategoryRuleRuleAndArrayInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleAndArrayOutput() CostCategoryRuleRuleAndArrayOutput
	ToCostCategoryRuleRuleAndArrayOutputWithContext(context.Context) CostCategoryRuleRuleAndArrayOutput
}

type CostCategoryRuleRuleAndArray []CostCategoryRuleRuleAndInput

func (CostCategoryRuleRuleAndArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CostCategoryRuleRuleAnd)(nil)).Elem()
}

func (i CostCategoryRuleRuleAndArray) ToCostCategoryRuleRuleAndArrayOutput() CostCategoryRuleRuleAndArrayOutput {
	return i.ToCostCategoryRuleRuleAndArrayOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleAndArray) ToCostCategoryRuleRuleAndArrayOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleAndArrayOutput)
}

type CostCategoryRuleRuleAndOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleAndOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleAnd)(nil)).Elem()
}

func (o CostCategoryRuleRuleAndOutput) ToCostCategoryRuleRuleAndOutput() CostCategoryRuleRuleAndOutput {
	return o
}

func (o CostCategoryRuleRuleAndOutput) ToCostCategoryRuleRuleAndOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndOutput {
	return o
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o CostCategoryRuleRuleAndOutput) CostCategory() CostCategoryRuleRuleAndCostCategoryPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAnd) *CostCategoryRuleRuleAndCostCategory { return v.CostCategory }).(CostCategoryRuleRuleAndCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o CostCategoryRuleRuleAndOutput) Dimension() CostCategoryRuleRuleAndDimensionPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAnd) *CostCategoryRuleRuleAndDimension { return v.Dimension }).(CostCategoryRuleRuleAndDimensionPtrOutput)
}

func (o CostCategoryRuleRuleAndOutput) Tags() CostCategoryRuleRuleAndTagsPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAnd) *CostCategoryRuleRuleAndTags { return v.Tags }).(CostCategoryRuleRuleAndTagsPtrOutput)
}

type CostCategoryRuleRuleAndArrayOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleAndArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CostCategoryRuleRuleAnd)(nil)).Elem()
}

func (o CostCategoryRuleRuleAndArrayOutput) ToCostCategoryRuleRuleAndArrayOutput() CostCategoryRuleRuleAndArrayOutput {
	return o
}

func (o CostCategoryRuleRuleAndArrayOutput) ToCostCategoryRuleRuleAndArrayOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndArrayOutput {
	return o
}

func (o CostCategoryRuleRuleAndArrayOutput) Index(i pulumi.IntInput) CostCategoryRuleRuleAndOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CostCategoryRuleRuleAnd {
		return vs[0].([]CostCategoryRuleRuleAnd)[vs[1].(int)]
	}).(CostCategoryRuleRuleAndOutput)
}

type CostCategoryRuleRuleAndCostCategory struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleAndCostCategoryInput is an input type that accepts CostCategoryRuleRuleAndCostCategoryArgs and CostCategoryRuleRuleAndCostCategoryOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleAndCostCategoryInput` via:
//
//          CostCategoryRuleRuleAndCostCategoryArgs{...}
type CostCategoryRuleRuleAndCostCategoryInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleAndCostCategoryOutput() CostCategoryRuleRuleAndCostCategoryOutput
	ToCostCategoryRuleRuleAndCostCategoryOutputWithContext(context.Context) CostCategoryRuleRuleAndCostCategoryOutput
}

type CostCategoryRuleRuleAndCostCategoryArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleAndCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleAndCostCategory)(nil)).Elem()
}

func (i CostCategoryRuleRuleAndCostCategoryArgs) ToCostCategoryRuleRuleAndCostCategoryOutput() CostCategoryRuleRuleAndCostCategoryOutput {
	return i.ToCostCategoryRuleRuleAndCostCategoryOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleAndCostCategoryArgs) ToCostCategoryRuleRuleAndCostCategoryOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleAndCostCategoryOutput)
}

func (i CostCategoryRuleRuleAndCostCategoryArgs) ToCostCategoryRuleRuleAndCostCategoryPtrOutput() CostCategoryRuleRuleAndCostCategoryPtrOutput {
	return i.ToCostCategoryRuleRuleAndCostCategoryPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleAndCostCategoryArgs) ToCostCategoryRuleRuleAndCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleAndCostCategoryOutput).ToCostCategoryRuleRuleAndCostCategoryPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleAndCostCategoryPtrInput is an input type that accepts CostCategoryRuleRuleAndCostCategoryArgs, CostCategoryRuleRuleAndCostCategoryPtr and CostCategoryRuleRuleAndCostCategoryPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleAndCostCategoryPtrInput` via:
//
//          CostCategoryRuleRuleAndCostCategoryArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleAndCostCategoryPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleAndCostCategoryPtrOutput() CostCategoryRuleRuleAndCostCategoryPtrOutput
	ToCostCategoryRuleRuleAndCostCategoryPtrOutputWithContext(context.Context) CostCategoryRuleRuleAndCostCategoryPtrOutput
}

type costCategoryRuleRuleAndCostCategoryPtrType CostCategoryRuleRuleAndCostCategoryArgs

func CostCategoryRuleRuleAndCostCategoryPtr(v *CostCategoryRuleRuleAndCostCategoryArgs) CostCategoryRuleRuleAndCostCategoryPtrInput {
	return (*costCategoryRuleRuleAndCostCategoryPtrType)(v)
}

func (*costCategoryRuleRuleAndCostCategoryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleAndCostCategory)(nil)).Elem()
}

func (i *costCategoryRuleRuleAndCostCategoryPtrType) ToCostCategoryRuleRuleAndCostCategoryPtrOutput() CostCategoryRuleRuleAndCostCategoryPtrOutput {
	return i.ToCostCategoryRuleRuleAndCostCategoryPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleAndCostCategoryPtrType) ToCostCategoryRuleRuleAndCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleAndCostCategoryPtrOutput)
}

type CostCategoryRuleRuleAndCostCategoryOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleAndCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleAndCostCategory)(nil)).Elem()
}

func (o CostCategoryRuleRuleAndCostCategoryOutput) ToCostCategoryRuleRuleAndCostCategoryOutput() CostCategoryRuleRuleAndCostCategoryOutput {
	return o
}

func (o CostCategoryRuleRuleAndCostCategoryOutput) ToCostCategoryRuleRuleAndCostCategoryOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndCostCategoryOutput {
	return o
}

func (o CostCategoryRuleRuleAndCostCategoryOutput) ToCostCategoryRuleRuleAndCostCategoryPtrOutput() CostCategoryRuleRuleAndCostCategoryPtrOutput {
	return o.ToCostCategoryRuleRuleAndCostCategoryPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleAndCostCategoryOutput) ToCostCategoryRuleRuleAndCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndCostCategoryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleAndCostCategory) *CostCategoryRuleRuleAndCostCategory {
		return &v
	}).(CostCategoryRuleRuleAndCostCategoryPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleAndCostCategoryOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAndCostCategory) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleAndCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAndCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleAndCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAndCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleAndCostCategoryPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleAndCostCategoryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleAndCostCategory)(nil)).Elem()
}

func (o CostCategoryRuleRuleAndCostCategoryPtrOutput) ToCostCategoryRuleRuleAndCostCategoryPtrOutput() CostCategoryRuleRuleAndCostCategoryPtrOutput {
	return o
}

func (o CostCategoryRuleRuleAndCostCategoryPtrOutput) ToCostCategoryRuleRuleAndCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndCostCategoryPtrOutput {
	return o
}

func (o CostCategoryRuleRuleAndCostCategoryPtrOutput) Elem() CostCategoryRuleRuleAndCostCategoryOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndCostCategory) CostCategoryRuleRuleAndCostCategory {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleAndCostCategory
		return ret
	}).(CostCategoryRuleRuleAndCostCategoryOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleAndCostCategoryPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndCostCategory) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleAndCostCategoryPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleAndCostCategoryPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleAndDimension struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleAndDimensionInput is an input type that accepts CostCategoryRuleRuleAndDimensionArgs and CostCategoryRuleRuleAndDimensionOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleAndDimensionInput` via:
//
//          CostCategoryRuleRuleAndDimensionArgs{...}
type CostCategoryRuleRuleAndDimensionInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleAndDimensionOutput() CostCategoryRuleRuleAndDimensionOutput
	ToCostCategoryRuleRuleAndDimensionOutputWithContext(context.Context) CostCategoryRuleRuleAndDimensionOutput
}

type CostCategoryRuleRuleAndDimensionArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleAndDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleAndDimension)(nil)).Elem()
}

func (i CostCategoryRuleRuleAndDimensionArgs) ToCostCategoryRuleRuleAndDimensionOutput() CostCategoryRuleRuleAndDimensionOutput {
	return i.ToCostCategoryRuleRuleAndDimensionOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleAndDimensionArgs) ToCostCategoryRuleRuleAndDimensionOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleAndDimensionOutput)
}

func (i CostCategoryRuleRuleAndDimensionArgs) ToCostCategoryRuleRuleAndDimensionPtrOutput() CostCategoryRuleRuleAndDimensionPtrOutput {
	return i.ToCostCategoryRuleRuleAndDimensionPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleAndDimensionArgs) ToCostCategoryRuleRuleAndDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleAndDimensionOutput).ToCostCategoryRuleRuleAndDimensionPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleAndDimensionPtrInput is an input type that accepts CostCategoryRuleRuleAndDimensionArgs, CostCategoryRuleRuleAndDimensionPtr and CostCategoryRuleRuleAndDimensionPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleAndDimensionPtrInput` via:
//
//          CostCategoryRuleRuleAndDimensionArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleAndDimensionPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleAndDimensionPtrOutput() CostCategoryRuleRuleAndDimensionPtrOutput
	ToCostCategoryRuleRuleAndDimensionPtrOutputWithContext(context.Context) CostCategoryRuleRuleAndDimensionPtrOutput
}

type costCategoryRuleRuleAndDimensionPtrType CostCategoryRuleRuleAndDimensionArgs

func CostCategoryRuleRuleAndDimensionPtr(v *CostCategoryRuleRuleAndDimensionArgs) CostCategoryRuleRuleAndDimensionPtrInput {
	return (*costCategoryRuleRuleAndDimensionPtrType)(v)
}

func (*costCategoryRuleRuleAndDimensionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleAndDimension)(nil)).Elem()
}

func (i *costCategoryRuleRuleAndDimensionPtrType) ToCostCategoryRuleRuleAndDimensionPtrOutput() CostCategoryRuleRuleAndDimensionPtrOutput {
	return i.ToCostCategoryRuleRuleAndDimensionPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleAndDimensionPtrType) ToCostCategoryRuleRuleAndDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleAndDimensionPtrOutput)
}

type CostCategoryRuleRuleAndDimensionOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleAndDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleAndDimension)(nil)).Elem()
}

func (o CostCategoryRuleRuleAndDimensionOutput) ToCostCategoryRuleRuleAndDimensionOutput() CostCategoryRuleRuleAndDimensionOutput {
	return o
}

func (o CostCategoryRuleRuleAndDimensionOutput) ToCostCategoryRuleRuleAndDimensionOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndDimensionOutput {
	return o
}

func (o CostCategoryRuleRuleAndDimensionOutput) ToCostCategoryRuleRuleAndDimensionPtrOutput() CostCategoryRuleRuleAndDimensionPtrOutput {
	return o.ToCostCategoryRuleRuleAndDimensionPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleAndDimensionOutput) ToCostCategoryRuleRuleAndDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndDimensionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleAndDimension) *CostCategoryRuleRuleAndDimension {
		return &v
	}).(CostCategoryRuleRuleAndDimensionPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleAndDimensionOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAndDimension) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleAndDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAndDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleAndDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAndDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleAndDimensionPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleAndDimensionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleAndDimension)(nil)).Elem()
}

func (o CostCategoryRuleRuleAndDimensionPtrOutput) ToCostCategoryRuleRuleAndDimensionPtrOutput() CostCategoryRuleRuleAndDimensionPtrOutput {
	return o
}

func (o CostCategoryRuleRuleAndDimensionPtrOutput) ToCostCategoryRuleRuleAndDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndDimensionPtrOutput {
	return o
}

func (o CostCategoryRuleRuleAndDimensionPtrOutput) Elem() CostCategoryRuleRuleAndDimensionOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndDimension) CostCategoryRuleRuleAndDimension {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleAndDimension
		return ret
	}).(CostCategoryRuleRuleAndDimensionOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleAndDimensionPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndDimension) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleAndDimensionPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndDimension) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleAndDimensionPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndDimension) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleAndTags struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleAndTagsInput is an input type that accepts CostCategoryRuleRuleAndTagsArgs and CostCategoryRuleRuleAndTagsOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleAndTagsInput` via:
//
//          CostCategoryRuleRuleAndTagsArgs{...}
type CostCategoryRuleRuleAndTagsInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleAndTagsOutput() CostCategoryRuleRuleAndTagsOutput
	ToCostCategoryRuleRuleAndTagsOutputWithContext(context.Context) CostCategoryRuleRuleAndTagsOutput
}

type CostCategoryRuleRuleAndTagsArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleAndTagsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleAndTags)(nil)).Elem()
}

func (i CostCategoryRuleRuleAndTagsArgs) ToCostCategoryRuleRuleAndTagsOutput() CostCategoryRuleRuleAndTagsOutput {
	return i.ToCostCategoryRuleRuleAndTagsOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleAndTagsArgs) ToCostCategoryRuleRuleAndTagsOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndTagsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleAndTagsOutput)
}

func (i CostCategoryRuleRuleAndTagsArgs) ToCostCategoryRuleRuleAndTagsPtrOutput() CostCategoryRuleRuleAndTagsPtrOutput {
	return i.ToCostCategoryRuleRuleAndTagsPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleAndTagsArgs) ToCostCategoryRuleRuleAndTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleAndTagsOutput).ToCostCategoryRuleRuleAndTagsPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleAndTagsPtrInput is an input type that accepts CostCategoryRuleRuleAndTagsArgs, CostCategoryRuleRuleAndTagsPtr and CostCategoryRuleRuleAndTagsPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleAndTagsPtrInput` via:
//
//          CostCategoryRuleRuleAndTagsArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleAndTagsPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleAndTagsPtrOutput() CostCategoryRuleRuleAndTagsPtrOutput
	ToCostCategoryRuleRuleAndTagsPtrOutputWithContext(context.Context) CostCategoryRuleRuleAndTagsPtrOutput
}

type costCategoryRuleRuleAndTagsPtrType CostCategoryRuleRuleAndTagsArgs

func CostCategoryRuleRuleAndTagsPtr(v *CostCategoryRuleRuleAndTagsArgs) CostCategoryRuleRuleAndTagsPtrInput {
	return (*costCategoryRuleRuleAndTagsPtrType)(v)
}

func (*costCategoryRuleRuleAndTagsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleAndTags)(nil)).Elem()
}

func (i *costCategoryRuleRuleAndTagsPtrType) ToCostCategoryRuleRuleAndTagsPtrOutput() CostCategoryRuleRuleAndTagsPtrOutput {
	return i.ToCostCategoryRuleRuleAndTagsPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleAndTagsPtrType) ToCostCategoryRuleRuleAndTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleAndTagsPtrOutput)
}

type CostCategoryRuleRuleAndTagsOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleAndTagsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleAndTags)(nil)).Elem()
}

func (o CostCategoryRuleRuleAndTagsOutput) ToCostCategoryRuleRuleAndTagsOutput() CostCategoryRuleRuleAndTagsOutput {
	return o
}

func (o CostCategoryRuleRuleAndTagsOutput) ToCostCategoryRuleRuleAndTagsOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndTagsOutput {
	return o
}

func (o CostCategoryRuleRuleAndTagsOutput) ToCostCategoryRuleRuleAndTagsPtrOutput() CostCategoryRuleRuleAndTagsPtrOutput {
	return o.ToCostCategoryRuleRuleAndTagsPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleAndTagsOutput) ToCostCategoryRuleRuleAndTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndTagsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleAndTags) *CostCategoryRuleRuleAndTags {
		return &v
	}).(CostCategoryRuleRuleAndTagsPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleAndTagsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAndTags) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleAndTagsOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAndTags) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleAndTagsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleAndTags) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleAndTagsPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleAndTagsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleAndTags)(nil)).Elem()
}

func (o CostCategoryRuleRuleAndTagsPtrOutput) ToCostCategoryRuleRuleAndTagsPtrOutput() CostCategoryRuleRuleAndTagsPtrOutput {
	return o
}

func (o CostCategoryRuleRuleAndTagsPtrOutput) ToCostCategoryRuleRuleAndTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleAndTagsPtrOutput {
	return o
}

func (o CostCategoryRuleRuleAndTagsPtrOutput) Elem() CostCategoryRuleRuleAndTagsOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndTags) CostCategoryRuleRuleAndTags {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleAndTags
		return ret
	}).(CostCategoryRuleRuleAndTagsOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleAndTagsPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndTags) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleAndTagsPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndTags) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleAndTagsPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleAndTags) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleCostCategory struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleCostCategoryInput is an input type that accepts CostCategoryRuleRuleCostCategoryArgs and CostCategoryRuleRuleCostCategoryOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleCostCategoryInput` via:
//
//          CostCategoryRuleRuleCostCategoryArgs{...}
type CostCategoryRuleRuleCostCategoryInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleCostCategoryOutput() CostCategoryRuleRuleCostCategoryOutput
	ToCostCategoryRuleRuleCostCategoryOutputWithContext(context.Context) CostCategoryRuleRuleCostCategoryOutput
}

type CostCategoryRuleRuleCostCategoryArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleCostCategory)(nil)).Elem()
}

func (i CostCategoryRuleRuleCostCategoryArgs) ToCostCategoryRuleRuleCostCategoryOutput() CostCategoryRuleRuleCostCategoryOutput {
	return i.ToCostCategoryRuleRuleCostCategoryOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleCostCategoryArgs) ToCostCategoryRuleRuleCostCategoryOutputWithContext(ctx context.Context) CostCategoryRuleRuleCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleCostCategoryOutput)
}

func (i CostCategoryRuleRuleCostCategoryArgs) ToCostCategoryRuleRuleCostCategoryPtrOutput() CostCategoryRuleRuleCostCategoryPtrOutput {
	return i.ToCostCategoryRuleRuleCostCategoryPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleCostCategoryArgs) ToCostCategoryRuleRuleCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleCostCategoryOutput).ToCostCategoryRuleRuleCostCategoryPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleCostCategoryPtrInput is an input type that accepts CostCategoryRuleRuleCostCategoryArgs, CostCategoryRuleRuleCostCategoryPtr and CostCategoryRuleRuleCostCategoryPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleCostCategoryPtrInput` via:
//
//          CostCategoryRuleRuleCostCategoryArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleCostCategoryPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleCostCategoryPtrOutput() CostCategoryRuleRuleCostCategoryPtrOutput
	ToCostCategoryRuleRuleCostCategoryPtrOutputWithContext(context.Context) CostCategoryRuleRuleCostCategoryPtrOutput
}

type costCategoryRuleRuleCostCategoryPtrType CostCategoryRuleRuleCostCategoryArgs

func CostCategoryRuleRuleCostCategoryPtr(v *CostCategoryRuleRuleCostCategoryArgs) CostCategoryRuleRuleCostCategoryPtrInput {
	return (*costCategoryRuleRuleCostCategoryPtrType)(v)
}

func (*costCategoryRuleRuleCostCategoryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleCostCategory)(nil)).Elem()
}

func (i *costCategoryRuleRuleCostCategoryPtrType) ToCostCategoryRuleRuleCostCategoryPtrOutput() CostCategoryRuleRuleCostCategoryPtrOutput {
	return i.ToCostCategoryRuleRuleCostCategoryPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleCostCategoryPtrType) ToCostCategoryRuleRuleCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleCostCategoryPtrOutput)
}

type CostCategoryRuleRuleCostCategoryOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleCostCategory)(nil)).Elem()
}

func (o CostCategoryRuleRuleCostCategoryOutput) ToCostCategoryRuleRuleCostCategoryOutput() CostCategoryRuleRuleCostCategoryOutput {
	return o
}

func (o CostCategoryRuleRuleCostCategoryOutput) ToCostCategoryRuleRuleCostCategoryOutputWithContext(ctx context.Context) CostCategoryRuleRuleCostCategoryOutput {
	return o
}

func (o CostCategoryRuleRuleCostCategoryOutput) ToCostCategoryRuleRuleCostCategoryPtrOutput() CostCategoryRuleRuleCostCategoryPtrOutput {
	return o.ToCostCategoryRuleRuleCostCategoryPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleCostCategoryOutput) ToCostCategoryRuleRuleCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleCostCategoryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleCostCategory) *CostCategoryRuleRuleCostCategory {
		return &v
	}).(CostCategoryRuleRuleCostCategoryPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleCostCategoryOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleCostCategory) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleCostCategoryPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleCostCategoryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleCostCategory)(nil)).Elem()
}

func (o CostCategoryRuleRuleCostCategoryPtrOutput) ToCostCategoryRuleRuleCostCategoryPtrOutput() CostCategoryRuleRuleCostCategoryPtrOutput {
	return o
}

func (o CostCategoryRuleRuleCostCategoryPtrOutput) ToCostCategoryRuleRuleCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleCostCategoryPtrOutput {
	return o
}

func (o CostCategoryRuleRuleCostCategoryPtrOutput) Elem() CostCategoryRuleRuleCostCategoryOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleCostCategory) CostCategoryRuleRuleCostCategory {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleCostCategory
		return ret
	}).(CostCategoryRuleRuleCostCategoryOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleCostCategoryPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleCostCategory) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleCostCategoryPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleCostCategoryPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleDimension struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleDimensionInput is an input type that accepts CostCategoryRuleRuleDimensionArgs and CostCategoryRuleRuleDimensionOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleDimensionInput` via:
//
//          CostCategoryRuleRuleDimensionArgs{...}
type CostCategoryRuleRuleDimensionInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleDimensionOutput() CostCategoryRuleRuleDimensionOutput
	ToCostCategoryRuleRuleDimensionOutputWithContext(context.Context) CostCategoryRuleRuleDimensionOutput
}

type CostCategoryRuleRuleDimensionArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleDimension)(nil)).Elem()
}

func (i CostCategoryRuleRuleDimensionArgs) ToCostCategoryRuleRuleDimensionOutput() CostCategoryRuleRuleDimensionOutput {
	return i.ToCostCategoryRuleRuleDimensionOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleDimensionArgs) ToCostCategoryRuleRuleDimensionOutputWithContext(ctx context.Context) CostCategoryRuleRuleDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleDimensionOutput)
}

func (i CostCategoryRuleRuleDimensionArgs) ToCostCategoryRuleRuleDimensionPtrOutput() CostCategoryRuleRuleDimensionPtrOutput {
	return i.ToCostCategoryRuleRuleDimensionPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleDimensionArgs) ToCostCategoryRuleRuleDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleDimensionOutput).ToCostCategoryRuleRuleDimensionPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleDimensionPtrInput is an input type that accepts CostCategoryRuleRuleDimensionArgs, CostCategoryRuleRuleDimensionPtr and CostCategoryRuleRuleDimensionPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleDimensionPtrInput` via:
//
//          CostCategoryRuleRuleDimensionArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleDimensionPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleDimensionPtrOutput() CostCategoryRuleRuleDimensionPtrOutput
	ToCostCategoryRuleRuleDimensionPtrOutputWithContext(context.Context) CostCategoryRuleRuleDimensionPtrOutput
}

type costCategoryRuleRuleDimensionPtrType CostCategoryRuleRuleDimensionArgs

func CostCategoryRuleRuleDimensionPtr(v *CostCategoryRuleRuleDimensionArgs) CostCategoryRuleRuleDimensionPtrInput {
	return (*costCategoryRuleRuleDimensionPtrType)(v)
}

func (*costCategoryRuleRuleDimensionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleDimension)(nil)).Elem()
}

func (i *costCategoryRuleRuleDimensionPtrType) ToCostCategoryRuleRuleDimensionPtrOutput() CostCategoryRuleRuleDimensionPtrOutput {
	return i.ToCostCategoryRuleRuleDimensionPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleDimensionPtrType) ToCostCategoryRuleRuleDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleDimensionPtrOutput)
}

type CostCategoryRuleRuleDimensionOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleDimension)(nil)).Elem()
}

func (o CostCategoryRuleRuleDimensionOutput) ToCostCategoryRuleRuleDimensionOutput() CostCategoryRuleRuleDimensionOutput {
	return o
}

func (o CostCategoryRuleRuleDimensionOutput) ToCostCategoryRuleRuleDimensionOutputWithContext(ctx context.Context) CostCategoryRuleRuleDimensionOutput {
	return o
}

func (o CostCategoryRuleRuleDimensionOutput) ToCostCategoryRuleRuleDimensionPtrOutput() CostCategoryRuleRuleDimensionPtrOutput {
	return o.ToCostCategoryRuleRuleDimensionPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleDimensionOutput) ToCostCategoryRuleRuleDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleDimensionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleDimension) *CostCategoryRuleRuleDimension {
		return &v
	}).(CostCategoryRuleRuleDimensionPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleDimensionOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleDimension) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleDimensionPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleDimensionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleDimension)(nil)).Elem()
}

func (o CostCategoryRuleRuleDimensionPtrOutput) ToCostCategoryRuleRuleDimensionPtrOutput() CostCategoryRuleRuleDimensionPtrOutput {
	return o
}

func (o CostCategoryRuleRuleDimensionPtrOutput) ToCostCategoryRuleRuleDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleDimensionPtrOutput {
	return o
}

func (o CostCategoryRuleRuleDimensionPtrOutput) Elem() CostCategoryRuleRuleDimensionOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleDimension) CostCategoryRuleRuleDimension {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleDimension
		return ret
	}).(CostCategoryRuleRuleDimensionOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleDimensionPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleDimension) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleDimensionPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleDimension) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleDimensionPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleDimension) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleNot struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory *CostCategoryRuleRuleNotCostCategory `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension *CostCategoryRuleRuleNotDimension `pulumi:"dimension"`
	Tags      *CostCategoryRuleRuleNotTags      `pulumi:"tags"`
}

// CostCategoryRuleRuleNotInput is an input type that accepts CostCategoryRuleRuleNotArgs and CostCategoryRuleRuleNotOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleNotInput` via:
//
//          CostCategoryRuleRuleNotArgs{...}
type CostCategoryRuleRuleNotInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleNotOutput() CostCategoryRuleRuleNotOutput
	ToCostCategoryRuleRuleNotOutputWithContext(context.Context) CostCategoryRuleRuleNotOutput
}

type CostCategoryRuleRuleNotArgs struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory CostCategoryRuleRuleNotCostCategoryPtrInput `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension CostCategoryRuleRuleNotDimensionPtrInput `pulumi:"dimension"`
	Tags      CostCategoryRuleRuleNotTagsPtrInput      `pulumi:"tags"`
}

func (CostCategoryRuleRuleNotArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleNot)(nil)).Elem()
}

func (i CostCategoryRuleRuleNotArgs) ToCostCategoryRuleRuleNotOutput() CostCategoryRuleRuleNotOutput {
	return i.ToCostCategoryRuleRuleNotOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleNotArgs) ToCostCategoryRuleRuleNotOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotOutput)
}

func (i CostCategoryRuleRuleNotArgs) ToCostCategoryRuleRuleNotPtrOutput() CostCategoryRuleRuleNotPtrOutput {
	return i.ToCostCategoryRuleRuleNotPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleNotArgs) ToCostCategoryRuleRuleNotPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotOutput).ToCostCategoryRuleRuleNotPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleNotPtrInput is an input type that accepts CostCategoryRuleRuleNotArgs, CostCategoryRuleRuleNotPtr and CostCategoryRuleRuleNotPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleNotPtrInput` via:
//
//          CostCategoryRuleRuleNotArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleNotPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleNotPtrOutput() CostCategoryRuleRuleNotPtrOutput
	ToCostCategoryRuleRuleNotPtrOutputWithContext(context.Context) CostCategoryRuleRuleNotPtrOutput
}

type costCategoryRuleRuleNotPtrType CostCategoryRuleRuleNotArgs

func CostCategoryRuleRuleNotPtr(v *CostCategoryRuleRuleNotArgs) CostCategoryRuleRuleNotPtrInput {
	return (*costCategoryRuleRuleNotPtrType)(v)
}

func (*costCategoryRuleRuleNotPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleNot)(nil)).Elem()
}

func (i *costCategoryRuleRuleNotPtrType) ToCostCategoryRuleRuleNotPtrOutput() CostCategoryRuleRuleNotPtrOutput {
	return i.ToCostCategoryRuleRuleNotPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleNotPtrType) ToCostCategoryRuleRuleNotPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotPtrOutput)
}

type CostCategoryRuleRuleNotOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleNotOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleNot)(nil)).Elem()
}

func (o CostCategoryRuleRuleNotOutput) ToCostCategoryRuleRuleNotOutput() CostCategoryRuleRuleNotOutput {
	return o
}

func (o CostCategoryRuleRuleNotOutput) ToCostCategoryRuleRuleNotOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotOutput {
	return o
}

func (o CostCategoryRuleRuleNotOutput) ToCostCategoryRuleRuleNotPtrOutput() CostCategoryRuleRuleNotPtrOutput {
	return o.ToCostCategoryRuleRuleNotPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleNotOutput) ToCostCategoryRuleRuleNotPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleNot) *CostCategoryRuleRuleNot {
		return &v
	}).(CostCategoryRuleRuleNotPtrOutput)
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o CostCategoryRuleRuleNotOutput) CostCategory() CostCategoryRuleRuleNotCostCategoryPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNot) *CostCategoryRuleRuleNotCostCategory { return v.CostCategory }).(CostCategoryRuleRuleNotCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o CostCategoryRuleRuleNotOutput) Dimension() CostCategoryRuleRuleNotDimensionPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNot) *CostCategoryRuleRuleNotDimension { return v.Dimension }).(CostCategoryRuleRuleNotDimensionPtrOutput)
}

func (o CostCategoryRuleRuleNotOutput) Tags() CostCategoryRuleRuleNotTagsPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNot) *CostCategoryRuleRuleNotTags { return v.Tags }).(CostCategoryRuleRuleNotTagsPtrOutput)
}

type CostCategoryRuleRuleNotPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleNotPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleNot)(nil)).Elem()
}

func (o CostCategoryRuleRuleNotPtrOutput) ToCostCategoryRuleRuleNotPtrOutput() CostCategoryRuleRuleNotPtrOutput {
	return o
}

func (o CostCategoryRuleRuleNotPtrOutput) ToCostCategoryRuleRuleNotPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotPtrOutput {
	return o
}

func (o CostCategoryRuleRuleNotPtrOutput) Elem() CostCategoryRuleRuleNotOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNot) CostCategoryRuleRuleNot {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleNot
		return ret
	}).(CostCategoryRuleRuleNotOutput)
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o CostCategoryRuleRuleNotPtrOutput) CostCategory() CostCategoryRuleRuleNotCostCategoryPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNot) *CostCategoryRuleRuleNotCostCategory {
		if v == nil {
			return nil
		}
		return v.CostCategory
	}).(CostCategoryRuleRuleNotCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o CostCategoryRuleRuleNotPtrOutput) Dimension() CostCategoryRuleRuleNotDimensionPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNot) *CostCategoryRuleRuleNotDimension {
		if v == nil {
			return nil
		}
		return v.Dimension
	}).(CostCategoryRuleRuleNotDimensionPtrOutput)
}

func (o CostCategoryRuleRuleNotPtrOutput) Tags() CostCategoryRuleRuleNotTagsPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNot) *CostCategoryRuleRuleNotTags {
		if v == nil {
			return nil
		}
		return v.Tags
	}).(CostCategoryRuleRuleNotTagsPtrOutput)
}

type CostCategoryRuleRuleNotCostCategory struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleNotCostCategoryInput is an input type that accepts CostCategoryRuleRuleNotCostCategoryArgs and CostCategoryRuleRuleNotCostCategoryOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleNotCostCategoryInput` via:
//
//          CostCategoryRuleRuleNotCostCategoryArgs{...}
type CostCategoryRuleRuleNotCostCategoryInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleNotCostCategoryOutput() CostCategoryRuleRuleNotCostCategoryOutput
	ToCostCategoryRuleRuleNotCostCategoryOutputWithContext(context.Context) CostCategoryRuleRuleNotCostCategoryOutput
}

type CostCategoryRuleRuleNotCostCategoryArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleNotCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleNotCostCategory)(nil)).Elem()
}

func (i CostCategoryRuleRuleNotCostCategoryArgs) ToCostCategoryRuleRuleNotCostCategoryOutput() CostCategoryRuleRuleNotCostCategoryOutput {
	return i.ToCostCategoryRuleRuleNotCostCategoryOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleNotCostCategoryArgs) ToCostCategoryRuleRuleNotCostCategoryOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotCostCategoryOutput)
}

func (i CostCategoryRuleRuleNotCostCategoryArgs) ToCostCategoryRuleRuleNotCostCategoryPtrOutput() CostCategoryRuleRuleNotCostCategoryPtrOutput {
	return i.ToCostCategoryRuleRuleNotCostCategoryPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleNotCostCategoryArgs) ToCostCategoryRuleRuleNotCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotCostCategoryOutput).ToCostCategoryRuleRuleNotCostCategoryPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleNotCostCategoryPtrInput is an input type that accepts CostCategoryRuleRuleNotCostCategoryArgs, CostCategoryRuleRuleNotCostCategoryPtr and CostCategoryRuleRuleNotCostCategoryPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleNotCostCategoryPtrInput` via:
//
//          CostCategoryRuleRuleNotCostCategoryArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleNotCostCategoryPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleNotCostCategoryPtrOutput() CostCategoryRuleRuleNotCostCategoryPtrOutput
	ToCostCategoryRuleRuleNotCostCategoryPtrOutputWithContext(context.Context) CostCategoryRuleRuleNotCostCategoryPtrOutput
}

type costCategoryRuleRuleNotCostCategoryPtrType CostCategoryRuleRuleNotCostCategoryArgs

func CostCategoryRuleRuleNotCostCategoryPtr(v *CostCategoryRuleRuleNotCostCategoryArgs) CostCategoryRuleRuleNotCostCategoryPtrInput {
	return (*costCategoryRuleRuleNotCostCategoryPtrType)(v)
}

func (*costCategoryRuleRuleNotCostCategoryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleNotCostCategory)(nil)).Elem()
}

func (i *costCategoryRuleRuleNotCostCategoryPtrType) ToCostCategoryRuleRuleNotCostCategoryPtrOutput() CostCategoryRuleRuleNotCostCategoryPtrOutput {
	return i.ToCostCategoryRuleRuleNotCostCategoryPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleNotCostCategoryPtrType) ToCostCategoryRuleRuleNotCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotCostCategoryPtrOutput)
}

type CostCategoryRuleRuleNotCostCategoryOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleNotCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleNotCostCategory)(nil)).Elem()
}

func (o CostCategoryRuleRuleNotCostCategoryOutput) ToCostCategoryRuleRuleNotCostCategoryOutput() CostCategoryRuleRuleNotCostCategoryOutput {
	return o
}

func (o CostCategoryRuleRuleNotCostCategoryOutput) ToCostCategoryRuleRuleNotCostCategoryOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotCostCategoryOutput {
	return o
}

func (o CostCategoryRuleRuleNotCostCategoryOutput) ToCostCategoryRuleRuleNotCostCategoryPtrOutput() CostCategoryRuleRuleNotCostCategoryPtrOutput {
	return o.ToCostCategoryRuleRuleNotCostCategoryPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleNotCostCategoryOutput) ToCostCategoryRuleRuleNotCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotCostCategoryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleNotCostCategory) *CostCategoryRuleRuleNotCostCategory {
		return &v
	}).(CostCategoryRuleRuleNotCostCategoryPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleNotCostCategoryOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNotCostCategory) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleNotCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNotCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleNotCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNotCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleNotCostCategoryPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleNotCostCategoryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleNotCostCategory)(nil)).Elem()
}

func (o CostCategoryRuleRuleNotCostCategoryPtrOutput) ToCostCategoryRuleRuleNotCostCategoryPtrOutput() CostCategoryRuleRuleNotCostCategoryPtrOutput {
	return o
}

func (o CostCategoryRuleRuleNotCostCategoryPtrOutput) ToCostCategoryRuleRuleNotCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotCostCategoryPtrOutput {
	return o
}

func (o CostCategoryRuleRuleNotCostCategoryPtrOutput) Elem() CostCategoryRuleRuleNotCostCategoryOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotCostCategory) CostCategoryRuleRuleNotCostCategory {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleNotCostCategory
		return ret
	}).(CostCategoryRuleRuleNotCostCategoryOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleNotCostCategoryPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotCostCategory) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleNotCostCategoryPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleNotCostCategoryPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleNotDimension struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleNotDimensionInput is an input type that accepts CostCategoryRuleRuleNotDimensionArgs and CostCategoryRuleRuleNotDimensionOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleNotDimensionInput` via:
//
//          CostCategoryRuleRuleNotDimensionArgs{...}
type CostCategoryRuleRuleNotDimensionInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleNotDimensionOutput() CostCategoryRuleRuleNotDimensionOutput
	ToCostCategoryRuleRuleNotDimensionOutputWithContext(context.Context) CostCategoryRuleRuleNotDimensionOutput
}

type CostCategoryRuleRuleNotDimensionArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleNotDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleNotDimension)(nil)).Elem()
}

func (i CostCategoryRuleRuleNotDimensionArgs) ToCostCategoryRuleRuleNotDimensionOutput() CostCategoryRuleRuleNotDimensionOutput {
	return i.ToCostCategoryRuleRuleNotDimensionOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleNotDimensionArgs) ToCostCategoryRuleRuleNotDimensionOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotDimensionOutput)
}

func (i CostCategoryRuleRuleNotDimensionArgs) ToCostCategoryRuleRuleNotDimensionPtrOutput() CostCategoryRuleRuleNotDimensionPtrOutput {
	return i.ToCostCategoryRuleRuleNotDimensionPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleNotDimensionArgs) ToCostCategoryRuleRuleNotDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotDimensionOutput).ToCostCategoryRuleRuleNotDimensionPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleNotDimensionPtrInput is an input type that accepts CostCategoryRuleRuleNotDimensionArgs, CostCategoryRuleRuleNotDimensionPtr and CostCategoryRuleRuleNotDimensionPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleNotDimensionPtrInput` via:
//
//          CostCategoryRuleRuleNotDimensionArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleNotDimensionPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleNotDimensionPtrOutput() CostCategoryRuleRuleNotDimensionPtrOutput
	ToCostCategoryRuleRuleNotDimensionPtrOutputWithContext(context.Context) CostCategoryRuleRuleNotDimensionPtrOutput
}

type costCategoryRuleRuleNotDimensionPtrType CostCategoryRuleRuleNotDimensionArgs

func CostCategoryRuleRuleNotDimensionPtr(v *CostCategoryRuleRuleNotDimensionArgs) CostCategoryRuleRuleNotDimensionPtrInput {
	return (*costCategoryRuleRuleNotDimensionPtrType)(v)
}

func (*costCategoryRuleRuleNotDimensionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleNotDimension)(nil)).Elem()
}

func (i *costCategoryRuleRuleNotDimensionPtrType) ToCostCategoryRuleRuleNotDimensionPtrOutput() CostCategoryRuleRuleNotDimensionPtrOutput {
	return i.ToCostCategoryRuleRuleNotDimensionPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleNotDimensionPtrType) ToCostCategoryRuleRuleNotDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotDimensionPtrOutput)
}

type CostCategoryRuleRuleNotDimensionOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleNotDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleNotDimension)(nil)).Elem()
}

func (o CostCategoryRuleRuleNotDimensionOutput) ToCostCategoryRuleRuleNotDimensionOutput() CostCategoryRuleRuleNotDimensionOutput {
	return o
}

func (o CostCategoryRuleRuleNotDimensionOutput) ToCostCategoryRuleRuleNotDimensionOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotDimensionOutput {
	return o
}

func (o CostCategoryRuleRuleNotDimensionOutput) ToCostCategoryRuleRuleNotDimensionPtrOutput() CostCategoryRuleRuleNotDimensionPtrOutput {
	return o.ToCostCategoryRuleRuleNotDimensionPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleNotDimensionOutput) ToCostCategoryRuleRuleNotDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotDimensionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleNotDimension) *CostCategoryRuleRuleNotDimension {
		return &v
	}).(CostCategoryRuleRuleNotDimensionPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleNotDimensionOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNotDimension) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleNotDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNotDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleNotDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNotDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleNotDimensionPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleNotDimensionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleNotDimension)(nil)).Elem()
}

func (o CostCategoryRuleRuleNotDimensionPtrOutput) ToCostCategoryRuleRuleNotDimensionPtrOutput() CostCategoryRuleRuleNotDimensionPtrOutput {
	return o
}

func (o CostCategoryRuleRuleNotDimensionPtrOutput) ToCostCategoryRuleRuleNotDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotDimensionPtrOutput {
	return o
}

func (o CostCategoryRuleRuleNotDimensionPtrOutput) Elem() CostCategoryRuleRuleNotDimensionOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotDimension) CostCategoryRuleRuleNotDimension {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleNotDimension
		return ret
	}).(CostCategoryRuleRuleNotDimensionOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleNotDimensionPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotDimension) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleNotDimensionPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotDimension) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleNotDimensionPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotDimension) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleNotTags struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleNotTagsInput is an input type that accepts CostCategoryRuleRuleNotTagsArgs and CostCategoryRuleRuleNotTagsOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleNotTagsInput` via:
//
//          CostCategoryRuleRuleNotTagsArgs{...}
type CostCategoryRuleRuleNotTagsInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleNotTagsOutput() CostCategoryRuleRuleNotTagsOutput
	ToCostCategoryRuleRuleNotTagsOutputWithContext(context.Context) CostCategoryRuleRuleNotTagsOutput
}

type CostCategoryRuleRuleNotTagsArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleNotTagsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleNotTags)(nil)).Elem()
}

func (i CostCategoryRuleRuleNotTagsArgs) ToCostCategoryRuleRuleNotTagsOutput() CostCategoryRuleRuleNotTagsOutput {
	return i.ToCostCategoryRuleRuleNotTagsOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleNotTagsArgs) ToCostCategoryRuleRuleNotTagsOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotTagsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotTagsOutput)
}

func (i CostCategoryRuleRuleNotTagsArgs) ToCostCategoryRuleRuleNotTagsPtrOutput() CostCategoryRuleRuleNotTagsPtrOutput {
	return i.ToCostCategoryRuleRuleNotTagsPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleNotTagsArgs) ToCostCategoryRuleRuleNotTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotTagsOutput).ToCostCategoryRuleRuleNotTagsPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleNotTagsPtrInput is an input type that accepts CostCategoryRuleRuleNotTagsArgs, CostCategoryRuleRuleNotTagsPtr and CostCategoryRuleRuleNotTagsPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleNotTagsPtrInput` via:
//
//          CostCategoryRuleRuleNotTagsArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleNotTagsPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleNotTagsPtrOutput() CostCategoryRuleRuleNotTagsPtrOutput
	ToCostCategoryRuleRuleNotTagsPtrOutputWithContext(context.Context) CostCategoryRuleRuleNotTagsPtrOutput
}

type costCategoryRuleRuleNotTagsPtrType CostCategoryRuleRuleNotTagsArgs

func CostCategoryRuleRuleNotTagsPtr(v *CostCategoryRuleRuleNotTagsArgs) CostCategoryRuleRuleNotTagsPtrInput {
	return (*costCategoryRuleRuleNotTagsPtrType)(v)
}

func (*costCategoryRuleRuleNotTagsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleNotTags)(nil)).Elem()
}

func (i *costCategoryRuleRuleNotTagsPtrType) ToCostCategoryRuleRuleNotTagsPtrOutput() CostCategoryRuleRuleNotTagsPtrOutput {
	return i.ToCostCategoryRuleRuleNotTagsPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleNotTagsPtrType) ToCostCategoryRuleRuleNotTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleNotTagsPtrOutput)
}

type CostCategoryRuleRuleNotTagsOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleNotTagsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleNotTags)(nil)).Elem()
}

func (o CostCategoryRuleRuleNotTagsOutput) ToCostCategoryRuleRuleNotTagsOutput() CostCategoryRuleRuleNotTagsOutput {
	return o
}

func (o CostCategoryRuleRuleNotTagsOutput) ToCostCategoryRuleRuleNotTagsOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotTagsOutput {
	return o
}

func (o CostCategoryRuleRuleNotTagsOutput) ToCostCategoryRuleRuleNotTagsPtrOutput() CostCategoryRuleRuleNotTagsPtrOutput {
	return o.ToCostCategoryRuleRuleNotTagsPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleNotTagsOutput) ToCostCategoryRuleRuleNotTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotTagsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleNotTags) *CostCategoryRuleRuleNotTags {
		return &v
	}).(CostCategoryRuleRuleNotTagsPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleNotTagsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNotTags) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleNotTagsOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNotTags) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleNotTagsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleNotTags) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleNotTagsPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleNotTagsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleNotTags)(nil)).Elem()
}

func (o CostCategoryRuleRuleNotTagsPtrOutput) ToCostCategoryRuleRuleNotTagsPtrOutput() CostCategoryRuleRuleNotTagsPtrOutput {
	return o
}

func (o CostCategoryRuleRuleNotTagsPtrOutput) ToCostCategoryRuleRuleNotTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleNotTagsPtrOutput {
	return o
}

func (o CostCategoryRuleRuleNotTagsPtrOutput) Elem() CostCategoryRuleRuleNotTagsOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotTags) CostCategoryRuleRuleNotTags {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleNotTags
		return ret
	}).(CostCategoryRuleRuleNotTagsOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleNotTagsPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotTags) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleNotTagsPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotTags) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleNotTagsPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleNotTags) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleOr struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory *CostCategoryRuleRuleOrCostCategory `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension *CostCategoryRuleRuleOrDimension `pulumi:"dimension"`
	Tags      *CostCategoryRuleRuleOrTags      `pulumi:"tags"`
}

// CostCategoryRuleRuleOrInput is an input type that accepts CostCategoryRuleRuleOrArgs and CostCategoryRuleRuleOrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleOrInput` via:
//
//          CostCategoryRuleRuleOrArgs{...}
type CostCategoryRuleRuleOrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleOrOutput() CostCategoryRuleRuleOrOutput
	ToCostCategoryRuleRuleOrOutputWithContext(context.Context) CostCategoryRuleRuleOrOutput
}

type CostCategoryRuleRuleOrArgs struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory CostCategoryRuleRuleOrCostCategoryPtrInput `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension CostCategoryRuleRuleOrDimensionPtrInput `pulumi:"dimension"`
	Tags      CostCategoryRuleRuleOrTagsPtrInput      `pulumi:"tags"`
}

func (CostCategoryRuleRuleOrArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleOr)(nil)).Elem()
}

func (i CostCategoryRuleRuleOrArgs) ToCostCategoryRuleRuleOrOutput() CostCategoryRuleRuleOrOutput {
	return i.ToCostCategoryRuleRuleOrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleOrArgs) ToCostCategoryRuleRuleOrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOrOutput)
}

// CostCategoryRuleRuleOrArrayInput is an input type that accepts CostCategoryRuleRuleOrArray and CostCategoryRuleRuleOrArrayOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleOrArrayInput` via:
//
//          CostCategoryRuleRuleOrArray{ CostCategoryRuleRuleOrArgs{...} }
type CostCategoryRuleRuleOrArrayInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleOrArrayOutput() CostCategoryRuleRuleOrArrayOutput
	ToCostCategoryRuleRuleOrArrayOutputWithContext(context.Context) CostCategoryRuleRuleOrArrayOutput
}

type CostCategoryRuleRuleOrArray []CostCategoryRuleRuleOrInput

func (CostCategoryRuleRuleOrArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CostCategoryRuleRuleOr)(nil)).Elem()
}

func (i CostCategoryRuleRuleOrArray) ToCostCategoryRuleRuleOrArrayOutput() CostCategoryRuleRuleOrArrayOutput {
	return i.ToCostCategoryRuleRuleOrArrayOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleOrArray) ToCostCategoryRuleRuleOrArrayOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOrArrayOutput)
}

type CostCategoryRuleRuleOrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleOrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleOr)(nil)).Elem()
}

func (o CostCategoryRuleRuleOrOutput) ToCostCategoryRuleRuleOrOutput() CostCategoryRuleRuleOrOutput {
	return o
}

func (o CostCategoryRuleRuleOrOutput) ToCostCategoryRuleRuleOrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrOutput {
	return o
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o CostCategoryRuleRuleOrOutput) CostCategory() CostCategoryRuleRuleOrCostCategoryPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOr) *CostCategoryRuleRuleOrCostCategory { return v.CostCategory }).(CostCategoryRuleRuleOrCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o CostCategoryRuleRuleOrOutput) Dimension() CostCategoryRuleRuleOrDimensionPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOr) *CostCategoryRuleRuleOrDimension { return v.Dimension }).(CostCategoryRuleRuleOrDimensionPtrOutput)
}

func (o CostCategoryRuleRuleOrOutput) Tags() CostCategoryRuleRuleOrTagsPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOr) *CostCategoryRuleRuleOrTags { return v.Tags }).(CostCategoryRuleRuleOrTagsPtrOutput)
}

type CostCategoryRuleRuleOrArrayOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleOrArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CostCategoryRuleRuleOr)(nil)).Elem()
}

func (o CostCategoryRuleRuleOrArrayOutput) ToCostCategoryRuleRuleOrArrayOutput() CostCategoryRuleRuleOrArrayOutput {
	return o
}

func (o CostCategoryRuleRuleOrArrayOutput) ToCostCategoryRuleRuleOrArrayOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrArrayOutput {
	return o
}

func (o CostCategoryRuleRuleOrArrayOutput) Index(i pulumi.IntInput) CostCategoryRuleRuleOrOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CostCategoryRuleRuleOr {
		return vs[0].([]CostCategoryRuleRuleOr)[vs[1].(int)]
	}).(CostCategoryRuleRuleOrOutput)
}

type CostCategoryRuleRuleOrCostCategory struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleOrCostCategoryInput is an input type that accepts CostCategoryRuleRuleOrCostCategoryArgs and CostCategoryRuleRuleOrCostCategoryOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleOrCostCategoryInput` via:
//
//          CostCategoryRuleRuleOrCostCategoryArgs{...}
type CostCategoryRuleRuleOrCostCategoryInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleOrCostCategoryOutput() CostCategoryRuleRuleOrCostCategoryOutput
	ToCostCategoryRuleRuleOrCostCategoryOutputWithContext(context.Context) CostCategoryRuleRuleOrCostCategoryOutput
}

type CostCategoryRuleRuleOrCostCategoryArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleOrCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleOrCostCategory)(nil)).Elem()
}

func (i CostCategoryRuleRuleOrCostCategoryArgs) ToCostCategoryRuleRuleOrCostCategoryOutput() CostCategoryRuleRuleOrCostCategoryOutput {
	return i.ToCostCategoryRuleRuleOrCostCategoryOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleOrCostCategoryArgs) ToCostCategoryRuleRuleOrCostCategoryOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOrCostCategoryOutput)
}

func (i CostCategoryRuleRuleOrCostCategoryArgs) ToCostCategoryRuleRuleOrCostCategoryPtrOutput() CostCategoryRuleRuleOrCostCategoryPtrOutput {
	return i.ToCostCategoryRuleRuleOrCostCategoryPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleOrCostCategoryArgs) ToCostCategoryRuleRuleOrCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOrCostCategoryOutput).ToCostCategoryRuleRuleOrCostCategoryPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleOrCostCategoryPtrInput is an input type that accepts CostCategoryRuleRuleOrCostCategoryArgs, CostCategoryRuleRuleOrCostCategoryPtr and CostCategoryRuleRuleOrCostCategoryPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleOrCostCategoryPtrInput` via:
//
//          CostCategoryRuleRuleOrCostCategoryArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleOrCostCategoryPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleOrCostCategoryPtrOutput() CostCategoryRuleRuleOrCostCategoryPtrOutput
	ToCostCategoryRuleRuleOrCostCategoryPtrOutputWithContext(context.Context) CostCategoryRuleRuleOrCostCategoryPtrOutput
}

type costCategoryRuleRuleOrCostCategoryPtrType CostCategoryRuleRuleOrCostCategoryArgs

func CostCategoryRuleRuleOrCostCategoryPtr(v *CostCategoryRuleRuleOrCostCategoryArgs) CostCategoryRuleRuleOrCostCategoryPtrInput {
	return (*costCategoryRuleRuleOrCostCategoryPtrType)(v)
}

func (*costCategoryRuleRuleOrCostCategoryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleOrCostCategory)(nil)).Elem()
}

func (i *costCategoryRuleRuleOrCostCategoryPtrType) ToCostCategoryRuleRuleOrCostCategoryPtrOutput() CostCategoryRuleRuleOrCostCategoryPtrOutput {
	return i.ToCostCategoryRuleRuleOrCostCategoryPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleOrCostCategoryPtrType) ToCostCategoryRuleRuleOrCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOrCostCategoryPtrOutput)
}

type CostCategoryRuleRuleOrCostCategoryOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleOrCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleOrCostCategory)(nil)).Elem()
}

func (o CostCategoryRuleRuleOrCostCategoryOutput) ToCostCategoryRuleRuleOrCostCategoryOutput() CostCategoryRuleRuleOrCostCategoryOutput {
	return o
}

func (o CostCategoryRuleRuleOrCostCategoryOutput) ToCostCategoryRuleRuleOrCostCategoryOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrCostCategoryOutput {
	return o
}

func (o CostCategoryRuleRuleOrCostCategoryOutput) ToCostCategoryRuleRuleOrCostCategoryPtrOutput() CostCategoryRuleRuleOrCostCategoryPtrOutput {
	return o.ToCostCategoryRuleRuleOrCostCategoryPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleOrCostCategoryOutput) ToCostCategoryRuleRuleOrCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrCostCategoryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleOrCostCategory) *CostCategoryRuleRuleOrCostCategory {
		return &v
	}).(CostCategoryRuleRuleOrCostCategoryPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleOrCostCategoryOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOrCostCategory) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleOrCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOrCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleOrCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOrCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleOrCostCategoryPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleOrCostCategoryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleOrCostCategory)(nil)).Elem()
}

func (o CostCategoryRuleRuleOrCostCategoryPtrOutput) ToCostCategoryRuleRuleOrCostCategoryPtrOutput() CostCategoryRuleRuleOrCostCategoryPtrOutput {
	return o
}

func (o CostCategoryRuleRuleOrCostCategoryPtrOutput) ToCostCategoryRuleRuleOrCostCategoryPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrCostCategoryPtrOutput {
	return o
}

func (o CostCategoryRuleRuleOrCostCategoryPtrOutput) Elem() CostCategoryRuleRuleOrCostCategoryOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrCostCategory) CostCategoryRuleRuleOrCostCategory {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleOrCostCategory
		return ret
	}).(CostCategoryRuleRuleOrCostCategoryOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleOrCostCategoryPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrCostCategory) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleOrCostCategoryPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleOrCostCategoryPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleOrDimension struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleOrDimensionInput is an input type that accepts CostCategoryRuleRuleOrDimensionArgs and CostCategoryRuleRuleOrDimensionOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleOrDimensionInput` via:
//
//          CostCategoryRuleRuleOrDimensionArgs{...}
type CostCategoryRuleRuleOrDimensionInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleOrDimensionOutput() CostCategoryRuleRuleOrDimensionOutput
	ToCostCategoryRuleRuleOrDimensionOutputWithContext(context.Context) CostCategoryRuleRuleOrDimensionOutput
}

type CostCategoryRuleRuleOrDimensionArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleOrDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleOrDimension)(nil)).Elem()
}

func (i CostCategoryRuleRuleOrDimensionArgs) ToCostCategoryRuleRuleOrDimensionOutput() CostCategoryRuleRuleOrDimensionOutput {
	return i.ToCostCategoryRuleRuleOrDimensionOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleOrDimensionArgs) ToCostCategoryRuleRuleOrDimensionOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOrDimensionOutput)
}

func (i CostCategoryRuleRuleOrDimensionArgs) ToCostCategoryRuleRuleOrDimensionPtrOutput() CostCategoryRuleRuleOrDimensionPtrOutput {
	return i.ToCostCategoryRuleRuleOrDimensionPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleOrDimensionArgs) ToCostCategoryRuleRuleOrDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOrDimensionOutput).ToCostCategoryRuleRuleOrDimensionPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleOrDimensionPtrInput is an input type that accepts CostCategoryRuleRuleOrDimensionArgs, CostCategoryRuleRuleOrDimensionPtr and CostCategoryRuleRuleOrDimensionPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleOrDimensionPtrInput` via:
//
//          CostCategoryRuleRuleOrDimensionArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleOrDimensionPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleOrDimensionPtrOutput() CostCategoryRuleRuleOrDimensionPtrOutput
	ToCostCategoryRuleRuleOrDimensionPtrOutputWithContext(context.Context) CostCategoryRuleRuleOrDimensionPtrOutput
}

type costCategoryRuleRuleOrDimensionPtrType CostCategoryRuleRuleOrDimensionArgs

func CostCategoryRuleRuleOrDimensionPtr(v *CostCategoryRuleRuleOrDimensionArgs) CostCategoryRuleRuleOrDimensionPtrInput {
	return (*costCategoryRuleRuleOrDimensionPtrType)(v)
}

func (*costCategoryRuleRuleOrDimensionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleOrDimension)(nil)).Elem()
}

func (i *costCategoryRuleRuleOrDimensionPtrType) ToCostCategoryRuleRuleOrDimensionPtrOutput() CostCategoryRuleRuleOrDimensionPtrOutput {
	return i.ToCostCategoryRuleRuleOrDimensionPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleOrDimensionPtrType) ToCostCategoryRuleRuleOrDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOrDimensionPtrOutput)
}

type CostCategoryRuleRuleOrDimensionOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleOrDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleOrDimension)(nil)).Elem()
}

func (o CostCategoryRuleRuleOrDimensionOutput) ToCostCategoryRuleRuleOrDimensionOutput() CostCategoryRuleRuleOrDimensionOutput {
	return o
}

func (o CostCategoryRuleRuleOrDimensionOutput) ToCostCategoryRuleRuleOrDimensionOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrDimensionOutput {
	return o
}

func (o CostCategoryRuleRuleOrDimensionOutput) ToCostCategoryRuleRuleOrDimensionPtrOutput() CostCategoryRuleRuleOrDimensionPtrOutput {
	return o.ToCostCategoryRuleRuleOrDimensionPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleOrDimensionOutput) ToCostCategoryRuleRuleOrDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrDimensionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleOrDimension) *CostCategoryRuleRuleOrDimension {
		return &v
	}).(CostCategoryRuleRuleOrDimensionPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleOrDimensionOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOrDimension) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleOrDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOrDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleOrDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOrDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleOrDimensionPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleOrDimensionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleOrDimension)(nil)).Elem()
}

func (o CostCategoryRuleRuleOrDimensionPtrOutput) ToCostCategoryRuleRuleOrDimensionPtrOutput() CostCategoryRuleRuleOrDimensionPtrOutput {
	return o
}

func (o CostCategoryRuleRuleOrDimensionPtrOutput) ToCostCategoryRuleRuleOrDimensionPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrDimensionPtrOutput {
	return o
}

func (o CostCategoryRuleRuleOrDimensionPtrOutput) Elem() CostCategoryRuleRuleOrDimensionOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrDimension) CostCategoryRuleRuleOrDimension {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleOrDimension
		return ret
	}).(CostCategoryRuleRuleOrDimensionOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleOrDimensionPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrDimension) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleOrDimensionPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrDimension) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleOrDimensionPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrDimension) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleOrTags struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleOrTagsInput is an input type that accepts CostCategoryRuleRuleOrTagsArgs and CostCategoryRuleRuleOrTagsOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleOrTagsInput` via:
//
//          CostCategoryRuleRuleOrTagsArgs{...}
type CostCategoryRuleRuleOrTagsInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleOrTagsOutput() CostCategoryRuleRuleOrTagsOutput
	ToCostCategoryRuleRuleOrTagsOutputWithContext(context.Context) CostCategoryRuleRuleOrTagsOutput
}

type CostCategoryRuleRuleOrTagsArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleOrTagsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleOrTags)(nil)).Elem()
}

func (i CostCategoryRuleRuleOrTagsArgs) ToCostCategoryRuleRuleOrTagsOutput() CostCategoryRuleRuleOrTagsOutput {
	return i.ToCostCategoryRuleRuleOrTagsOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleOrTagsArgs) ToCostCategoryRuleRuleOrTagsOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrTagsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOrTagsOutput)
}

func (i CostCategoryRuleRuleOrTagsArgs) ToCostCategoryRuleRuleOrTagsPtrOutput() CostCategoryRuleRuleOrTagsPtrOutput {
	return i.ToCostCategoryRuleRuleOrTagsPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleOrTagsArgs) ToCostCategoryRuleRuleOrTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOrTagsOutput).ToCostCategoryRuleRuleOrTagsPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleOrTagsPtrInput is an input type that accepts CostCategoryRuleRuleOrTagsArgs, CostCategoryRuleRuleOrTagsPtr and CostCategoryRuleRuleOrTagsPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleOrTagsPtrInput` via:
//
//          CostCategoryRuleRuleOrTagsArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleOrTagsPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleOrTagsPtrOutput() CostCategoryRuleRuleOrTagsPtrOutput
	ToCostCategoryRuleRuleOrTagsPtrOutputWithContext(context.Context) CostCategoryRuleRuleOrTagsPtrOutput
}

type costCategoryRuleRuleOrTagsPtrType CostCategoryRuleRuleOrTagsArgs

func CostCategoryRuleRuleOrTagsPtr(v *CostCategoryRuleRuleOrTagsArgs) CostCategoryRuleRuleOrTagsPtrInput {
	return (*costCategoryRuleRuleOrTagsPtrType)(v)
}

func (*costCategoryRuleRuleOrTagsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleOrTags)(nil)).Elem()
}

func (i *costCategoryRuleRuleOrTagsPtrType) ToCostCategoryRuleRuleOrTagsPtrOutput() CostCategoryRuleRuleOrTagsPtrOutput {
	return i.ToCostCategoryRuleRuleOrTagsPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleOrTagsPtrType) ToCostCategoryRuleRuleOrTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleOrTagsPtrOutput)
}

type CostCategoryRuleRuleOrTagsOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleOrTagsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleOrTags)(nil)).Elem()
}

func (o CostCategoryRuleRuleOrTagsOutput) ToCostCategoryRuleRuleOrTagsOutput() CostCategoryRuleRuleOrTagsOutput {
	return o
}

func (o CostCategoryRuleRuleOrTagsOutput) ToCostCategoryRuleRuleOrTagsOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrTagsOutput {
	return o
}

func (o CostCategoryRuleRuleOrTagsOutput) ToCostCategoryRuleRuleOrTagsPtrOutput() CostCategoryRuleRuleOrTagsPtrOutput {
	return o.ToCostCategoryRuleRuleOrTagsPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleOrTagsOutput) ToCostCategoryRuleRuleOrTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrTagsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleOrTags) *CostCategoryRuleRuleOrTags {
		return &v
	}).(CostCategoryRuleRuleOrTagsPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleOrTagsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOrTags) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleOrTagsOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOrTags) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleOrTagsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleOrTags) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleOrTagsPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleOrTagsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleOrTags)(nil)).Elem()
}

func (o CostCategoryRuleRuleOrTagsPtrOutput) ToCostCategoryRuleRuleOrTagsPtrOutput() CostCategoryRuleRuleOrTagsPtrOutput {
	return o
}

func (o CostCategoryRuleRuleOrTagsPtrOutput) ToCostCategoryRuleRuleOrTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleOrTagsPtrOutput {
	return o
}

func (o CostCategoryRuleRuleOrTagsPtrOutput) Elem() CostCategoryRuleRuleOrTagsOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrTags) CostCategoryRuleRuleOrTags {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleOrTags
		return ret
	}).(CostCategoryRuleRuleOrTagsOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleOrTagsPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrTags) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleOrTagsPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrTags) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleOrTagsPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleOrTags) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleTags struct {
	// Key for the tag.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategoryRuleRuleTagsInput is an input type that accepts CostCategoryRuleRuleTagsArgs and CostCategoryRuleRuleTagsOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleTagsInput` via:
//
//          CostCategoryRuleRuleTagsArgs{...}
type CostCategoryRuleRuleTagsInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleTagsOutput() CostCategoryRuleRuleTagsOutput
	ToCostCategoryRuleRuleTagsOutputWithContext(context.Context) CostCategoryRuleRuleTagsOutput
}

type CostCategoryRuleRuleTagsArgs struct {
	// Key for the tag.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategoryRuleRuleTagsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleTags)(nil)).Elem()
}

func (i CostCategoryRuleRuleTagsArgs) ToCostCategoryRuleRuleTagsOutput() CostCategoryRuleRuleTagsOutput {
	return i.ToCostCategoryRuleRuleTagsOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleTagsArgs) ToCostCategoryRuleRuleTagsOutputWithContext(ctx context.Context) CostCategoryRuleRuleTagsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleTagsOutput)
}

func (i CostCategoryRuleRuleTagsArgs) ToCostCategoryRuleRuleTagsPtrOutput() CostCategoryRuleRuleTagsPtrOutput {
	return i.ToCostCategoryRuleRuleTagsPtrOutputWithContext(context.Background())
}

func (i CostCategoryRuleRuleTagsArgs) ToCostCategoryRuleRuleTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleTagsOutput).ToCostCategoryRuleRuleTagsPtrOutputWithContext(ctx)
}

// CostCategoryRuleRuleTagsPtrInput is an input type that accepts CostCategoryRuleRuleTagsArgs, CostCategoryRuleRuleTagsPtr and CostCategoryRuleRuleTagsPtrOutput values.
// You can construct a concrete instance of `CostCategoryRuleRuleTagsPtrInput` via:
//
//          CostCategoryRuleRuleTagsArgs{...}
//
//  or:
//
//          nil
type CostCategoryRuleRuleTagsPtrInput interface {
	pulumi.Input

	ToCostCategoryRuleRuleTagsPtrOutput() CostCategoryRuleRuleTagsPtrOutput
	ToCostCategoryRuleRuleTagsPtrOutputWithContext(context.Context) CostCategoryRuleRuleTagsPtrOutput
}

type costCategoryRuleRuleTagsPtrType CostCategoryRuleRuleTagsArgs

func CostCategoryRuleRuleTagsPtr(v *CostCategoryRuleRuleTagsArgs) CostCategoryRuleRuleTagsPtrInput {
	return (*costCategoryRuleRuleTagsPtrType)(v)
}

func (*costCategoryRuleRuleTagsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleTags)(nil)).Elem()
}

func (i *costCategoryRuleRuleTagsPtrType) ToCostCategoryRuleRuleTagsPtrOutput() CostCategoryRuleRuleTagsPtrOutput {
	return i.ToCostCategoryRuleRuleTagsPtrOutputWithContext(context.Background())
}

func (i *costCategoryRuleRuleTagsPtrType) ToCostCategoryRuleRuleTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategoryRuleRuleTagsPtrOutput)
}

type CostCategoryRuleRuleTagsOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleTagsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategoryRuleRuleTags)(nil)).Elem()
}

func (o CostCategoryRuleRuleTagsOutput) ToCostCategoryRuleRuleTagsOutput() CostCategoryRuleRuleTagsOutput {
	return o
}

func (o CostCategoryRuleRuleTagsOutput) ToCostCategoryRuleRuleTagsOutputWithContext(ctx context.Context) CostCategoryRuleRuleTagsOutput {
	return o
}

func (o CostCategoryRuleRuleTagsOutput) ToCostCategoryRuleRuleTagsPtrOutput() CostCategoryRuleRuleTagsPtrOutput {
	return o.ToCostCategoryRuleRuleTagsPtrOutputWithContext(context.Background())
}

func (o CostCategoryRuleRuleTagsOutput) ToCostCategoryRuleRuleTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleTagsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CostCategoryRuleRuleTags) *CostCategoryRuleRuleTags {
		return &v
	}).(CostCategoryRuleRuleTagsPtrOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleTagsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleTags) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleTagsOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleTags) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleTagsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategoryRuleRuleTags) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategoryRuleRuleTagsPtrOutput struct{ *pulumi.OutputState }

func (CostCategoryRuleRuleTagsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CostCategoryRuleRuleTags)(nil)).Elem()
}

func (o CostCategoryRuleRuleTagsPtrOutput) ToCostCategoryRuleRuleTagsPtrOutput() CostCategoryRuleRuleTagsPtrOutput {
	return o
}

func (o CostCategoryRuleRuleTagsPtrOutput) ToCostCategoryRuleRuleTagsPtrOutputWithContext(ctx context.Context) CostCategoryRuleRuleTagsPtrOutput {
	return o
}

func (o CostCategoryRuleRuleTagsPtrOutput) Elem() CostCategoryRuleRuleTagsOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleTags) CostCategoryRuleRuleTags {
		if v != nil {
			return *v
		}
		var ret CostCategoryRuleRuleTags
		return ret
	}).(CostCategoryRuleRuleTagsOutput)
}

// Key for the tag.
func (o CostCategoryRuleRuleTagsPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleTags) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o CostCategoryRuleRuleTagsPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleTags) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o CostCategoryRuleRuleTagsPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CostCategoryRuleRuleTags) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type CostCategorySplitChargeRule struct {
	// Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
	Method string `pulumi:"method"`
	// Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
	Parameters []CostCategorySplitChargeRuleParameter `pulumi:"parameters"`
	// Cost Category value that you want to split.
	Source string `pulumi:"source"`
	// Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
	Targets []string `pulumi:"targets"`
}

// CostCategorySplitChargeRuleInput is an input type that accepts CostCategorySplitChargeRuleArgs and CostCategorySplitChargeRuleOutput values.
// You can construct a concrete instance of `CostCategorySplitChargeRuleInput` via:
//
//          CostCategorySplitChargeRuleArgs{...}
type CostCategorySplitChargeRuleInput interface {
	pulumi.Input

	ToCostCategorySplitChargeRuleOutput() CostCategorySplitChargeRuleOutput
	ToCostCategorySplitChargeRuleOutputWithContext(context.Context) CostCategorySplitChargeRuleOutput
}

type CostCategorySplitChargeRuleArgs struct {
	// Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
	Method pulumi.StringInput `pulumi:"method"`
	// Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
	Parameters CostCategorySplitChargeRuleParameterArrayInput `pulumi:"parameters"`
	// Cost Category value that you want to split.
	Source pulumi.StringInput `pulumi:"source"`
	// Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
	Targets pulumi.StringArrayInput `pulumi:"targets"`
}

func (CostCategorySplitChargeRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategorySplitChargeRule)(nil)).Elem()
}

func (i CostCategorySplitChargeRuleArgs) ToCostCategorySplitChargeRuleOutput() CostCategorySplitChargeRuleOutput {
	return i.ToCostCategorySplitChargeRuleOutputWithContext(context.Background())
}

func (i CostCategorySplitChargeRuleArgs) ToCostCategorySplitChargeRuleOutputWithContext(ctx context.Context) CostCategorySplitChargeRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategorySplitChargeRuleOutput)
}

// CostCategorySplitChargeRuleArrayInput is an input type that accepts CostCategorySplitChargeRuleArray and CostCategorySplitChargeRuleArrayOutput values.
// You can construct a concrete instance of `CostCategorySplitChargeRuleArrayInput` via:
//
//          CostCategorySplitChargeRuleArray{ CostCategorySplitChargeRuleArgs{...} }
type CostCategorySplitChargeRuleArrayInput interface {
	pulumi.Input

	ToCostCategorySplitChargeRuleArrayOutput() CostCategorySplitChargeRuleArrayOutput
	ToCostCategorySplitChargeRuleArrayOutputWithContext(context.Context) CostCategorySplitChargeRuleArrayOutput
}

type CostCategorySplitChargeRuleArray []CostCategorySplitChargeRuleInput

func (CostCategorySplitChargeRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CostCategorySplitChargeRule)(nil)).Elem()
}

func (i CostCategorySplitChargeRuleArray) ToCostCategorySplitChargeRuleArrayOutput() CostCategorySplitChargeRuleArrayOutput {
	return i.ToCostCategorySplitChargeRuleArrayOutputWithContext(context.Background())
}

func (i CostCategorySplitChargeRuleArray) ToCostCategorySplitChargeRuleArrayOutputWithContext(ctx context.Context) CostCategorySplitChargeRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategorySplitChargeRuleArrayOutput)
}

type CostCategorySplitChargeRuleOutput struct{ *pulumi.OutputState }

func (CostCategorySplitChargeRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategorySplitChargeRule)(nil)).Elem()
}

func (o CostCategorySplitChargeRuleOutput) ToCostCategorySplitChargeRuleOutput() CostCategorySplitChargeRuleOutput {
	return o
}

func (o CostCategorySplitChargeRuleOutput) ToCostCategorySplitChargeRuleOutputWithContext(ctx context.Context) CostCategorySplitChargeRuleOutput {
	return o
}

// Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
func (o CostCategorySplitChargeRuleOutput) Method() pulumi.StringOutput {
	return o.ApplyT(func(v CostCategorySplitChargeRule) string { return v.Method }).(pulumi.StringOutput)
}

// Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
func (o CostCategorySplitChargeRuleOutput) Parameters() CostCategorySplitChargeRuleParameterArrayOutput {
	return o.ApplyT(func(v CostCategorySplitChargeRule) []CostCategorySplitChargeRuleParameter { return v.Parameters }).(CostCategorySplitChargeRuleParameterArrayOutput)
}

// Cost Category value that you want to split.
func (o CostCategorySplitChargeRuleOutput) Source() pulumi.StringOutput {
	return o.ApplyT(func(v CostCategorySplitChargeRule) string { return v.Source }).(pulumi.StringOutput)
}

// Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
func (o CostCategorySplitChargeRuleOutput) Targets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategorySplitChargeRule) []string { return v.Targets }).(pulumi.StringArrayOutput)
}

type CostCategorySplitChargeRuleArrayOutput struct{ *pulumi.OutputState }

func (CostCategorySplitChargeRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CostCategorySplitChargeRule)(nil)).Elem()
}

func (o CostCategorySplitChargeRuleArrayOutput) ToCostCategorySplitChargeRuleArrayOutput() CostCategorySplitChargeRuleArrayOutput {
	return o
}

func (o CostCategorySplitChargeRuleArrayOutput) ToCostCategorySplitChargeRuleArrayOutputWithContext(ctx context.Context) CostCategorySplitChargeRuleArrayOutput {
	return o
}

func (o CostCategorySplitChargeRuleArrayOutput) Index(i pulumi.IntInput) CostCategorySplitChargeRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CostCategorySplitChargeRule {
		return vs[0].([]CostCategorySplitChargeRule)[vs[1].(int)]
	}).(CostCategorySplitChargeRuleOutput)
}

type CostCategorySplitChargeRuleParameter struct {
	// Parameter type.
	Type *string `pulumi:"type"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// CostCategorySplitChargeRuleParameterInput is an input type that accepts CostCategorySplitChargeRuleParameterArgs and CostCategorySplitChargeRuleParameterOutput values.
// You can construct a concrete instance of `CostCategorySplitChargeRuleParameterInput` via:
//
//          CostCategorySplitChargeRuleParameterArgs{...}
type CostCategorySplitChargeRuleParameterInput interface {
	pulumi.Input

	ToCostCategorySplitChargeRuleParameterOutput() CostCategorySplitChargeRuleParameterOutput
	ToCostCategorySplitChargeRuleParameterOutputWithContext(context.Context) CostCategorySplitChargeRuleParameterOutput
}

type CostCategorySplitChargeRuleParameterArgs struct {
	// Parameter type.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (CostCategorySplitChargeRuleParameterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategorySplitChargeRuleParameter)(nil)).Elem()
}

func (i CostCategorySplitChargeRuleParameterArgs) ToCostCategorySplitChargeRuleParameterOutput() CostCategorySplitChargeRuleParameterOutput {
	return i.ToCostCategorySplitChargeRuleParameterOutputWithContext(context.Background())
}

func (i CostCategorySplitChargeRuleParameterArgs) ToCostCategorySplitChargeRuleParameterOutputWithContext(ctx context.Context) CostCategorySplitChargeRuleParameterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategorySplitChargeRuleParameterOutput)
}

// CostCategorySplitChargeRuleParameterArrayInput is an input type that accepts CostCategorySplitChargeRuleParameterArray and CostCategorySplitChargeRuleParameterArrayOutput values.
// You can construct a concrete instance of `CostCategorySplitChargeRuleParameterArrayInput` via:
//
//          CostCategorySplitChargeRuleParameterArray{ CostCategorySplitChargeRuleParameterArgs{...} }
type CostCategorySplitChargeRuleParameterArrayInput interface {
	pulumi.Input

	ToCostCategorySplitChargeRuleParameterArrayOutput() CostCategorySplitChargeRuleParameterArrayOutput
	ToCostCategorySplitChargeRuleParameterArrayOutputWithContext(context.Context) CostCategorySplitChargeRuleParameterArrayOutput
}

type CostCategorySplitChargeRuleParameterArray []CostCategorySplitChargeRuleParameterInput

func (CostCategorySplitChargeRuleParameterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CostCategorySplitChargeRuleParameter)(nil)).Elem()
}

func (i CostCategorySplitChargeRuleParameterArray) ToCostCategorySplitChargeRuleParameterArrayOutput() CostCategorySplitChargeRuleParameterArrayOutput {
	return i.ToCostCategorySplitChargeRuleParameterArrayOutputWithContext(context.Background())
}

func (i CostCategorySplitChargeRuleParameterArray) ToCostCategorySplitChargeRuleParameterArrayOutputWithContext(ctx context.Context) CostCategorySplitChargeRuleParameterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CostCategorySplitChargeRuleParameterArrayOutput)
}

type CostCategorySplitChargeRuleParameterOutput struct{ *pulumi.OutputState }

func (CostCategorySplitChargeRuleParameterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CostCategorySplitChargeRuleParameter)(nil)).Elem()
}

func (o CostCategorySplitChargeRuleParameterOutput) ToCostCategorySplitChargeRuleParameterOutput() CostCategorySplitChargeRuleParameterOutput {
	return o
}

func (o CostCategorySplitChargeRuleParameterOutput) ToCostCategorySplitChargeRuleParameterOutputWithContext(ctx context.Context) CostCategorySplitChargeRuleParameterOutput {
	return o
}

// Parameter type.
func (o CostCategorySplitChargeRuleParameterOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CostCategorySplitChargeRuleParameter) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Parameter values.
func (o CostCategorySplitChargeRuleParameterOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CostCategorySplitChargeRuleParameter) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type CostCategorySplitChargeRuleParameterArrayOutput struct{ *pulumi.OutputState }

func (CostCategorySplitChargeRuleParameterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CostCategorySplitChargeRuleParameter)(nil)).Elem()
}

func (o CostCategorySplitChargeRuleParameterArrayOutput) ToCostCategorySplitChargeRuleParameterArrayOutput() CostCategorySplitChargeRuleParameterArrayOutput {
	return o
}

func (o CostCategorySplitChargeRuleParameterArrayOutput) ToCostCategorySplitChargeRuleParameterArrayOutputWithContext(ctx context.Context) CostCategorySplitChargeRuleParameterArrayOutput {
	return o
}

func (o CostCategorySplitChargeRuleParameterArrayOutput) Index(i pulumi.IntInput) CostCategorySplitChargeRuleParameterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CostCategorySplitChargeRuleParameter {
		return vs[0].([]CostCategorySplitChargeRuleParameter)[vs[1].(int)]
	}).(CostCategorySplitChargeRuleParameterOutput)
}

type TagsFilter struct {
	// Return results that match both `Dimension` objects.
	Ands []TagsFilterAnd `pulumi:"ands"`
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory *TagsFilterCostCategory `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension *TagsFilterDimension `pulumi:"dimension"`
	// Return results that match both `Dimension` object.
	Not *TagsFilterNot `pulumi:"not"`
	// Return results that match both `Dimension` object.
	Ors []TagsFilterOr `pulumi:"ors"`
	// Tags that match your request.
	Tags *TagsFilterTags `pulumi:"tags"`
}

// TagsFilterInput is an input type that accepts TagsFilterArgs and TagsFilterOutput values.
// You can construct a concrete instance of `TagsFilterInput` via:
//
//          TagsFilterArgs{...}
type TagsFilterInput interface {
	pulumi.Input

	ToTagsFilterOutput() TagsFilterOutput
	ToTagsFilterOutputWithContext(context.Context) TagsFilterOutput
}

type TagsFilterArgs struct {
	// Return results that match both `Dimension` objects.
	Ands TagsFilterAndArrayInput `pulumi:"ands"`
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory TagsFilterCostCategoryPtrInput `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension TagsFilterDimensionPtrInput `pulumi:"dimension"`
	// Return results that match both `Dimension` object.
	Not TagsFilterNotPtrInput `pulumi:"not"`
	// Return results that match both `Dimension` object.
	Ors TagsFilterOrArrayInput `pulumi:"ors"`
	// Tags that match your request.
	Tags TagsFilterTagsPtrInput `pulumi:"tags"`
}

func (TagsFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilter)(nil)).Elem()
}

func (i TagsFilterArgs) ToTagsFilterOutput() TagsFilterOutput {
	return i.ToTagsFilterOutputWithContext(context.Background())
}

func (i TagsFilterArgs) ToTagsFilterOutputWithContext(ctx context.Context) TagsFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOutput)
}

func (i TagsFilterArgs) ToTagsFilterPtrOutput() TagsFilterPtrOutput {
	return i.ToTagsFilterPtrOutputWithContext(context.Background())
}

func (i TagsFilterArgs) ToTagsFilterPtrOutputWithContext(ctx context.Context) TagsFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOutput).ToTagsFilterPtrOutputWithContext(ctx)
}

// TagsFilterPtrInput is an input type that accepts TagsFilterArgs, TagsFilterPtr and TagsFilterPtrOutput values.
// You can construct a concrete instance of `TagsFilterPtrInput` via:
//
//          TagsFilterArgs{...}
//
//  or:
//
//          nil
type TagsFilterPtrInput interface {
	pulumi.Input

	ToTagsFilterPtrOutput() TagsFilterPtrOutput
	ToTagsFilterPtrOutputWithContext(context.Context) TagsFilterPtrOutput
}

type tagsFilterPtrType TagsFilterArgs

func TagsFilterPtr(v *TagsFilterArgs) TagsFilterPtrInput {
	return (*tagsFilterPtrType)(v)
}

func (*tagsFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilter)(nil)).Elem()
}

func (i *tagsFilterPtrType) ToTagsFilterPtrOutput() TagsFilterPtrOutput {
	return i.ToTagsFilterPtrOutputWithContext(context.Background())
}

func (i *tagsFilterPtrType) ToTagsFilterPtrOutputWithContext(ctx context.Context) TagsFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterPtrOutput)
}

type TagsFilterOutput struct{ *pulumi.OutputState }

func (TagsFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilter)(nil)).Elem()
}

func (o TagsFilterOutput) ToTagsFilterOutput() TagsFilterOutput {
	return o
}

func (o TagsFilterOutput) ToTagsFilterOutputWithContext(ctx context.Context) TagsFilterOutput {
	return o
}

func (o TagsFilterOutput) ToTagsFilterPtrOutput() TagsFilterPtrOutput {
	return o.ToTagsFilterPtrOutputWithContext(context.Background())
}

func (o TagsFilterOutput) ToTagsFilterPtrOutputWithContext(ctx context.Context) TagsFilterPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilter) *TagsFilter {
		return &v
	}).(TagsFilterPtrOutput)
}

// Return results that match both `Dimension` objects.
func (o TagsFilterOutput) Ands() TagsFilterAndArrayOutput {
	return o.ApplyT(func(v TagsFilter) []TagsFilterAnd { return v.Ands }).(TagsFilterAndArrayOutput)
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o TagsFilterOutput) CostCategory() TagsFilterCostCategoryPtrOutput {
	return o.ApplyT(func(v TagsFilter) *TagsFilterCostCategory { return v.CostCategory }).(TagsFilterCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o TagsFilterOutput) Dimension() TagsFilterDimensionPtrOutput {
	return o.ApplyT(func(v TagsFilter) *TagsFilterDimension { return v.Dimension }).(TagsFilterDimensionPtrOutput)
}

// Return results that match both `Dimension` object.
func (o TagsFilterOutput) Not() TagsFilterNotPtrOutput {
	return o.ApplyT(func(v TagsFilter) *TagsFilterNot { return v.Not }).(TagsFilterNotPtrOutput)
}

// Return results that match both `Dimension` object.
func (o TagsFilterOutput) Ors() TagsFilterOrArrayOutput {
	return o.ApplyT(func(v TagsFilter) []TagsFilterOr { return v.Ors }).(TagsFilterOrArrayOutput)
}

// Tags that match your request.
func (o TagsFilterOutput) Tags() TagsFilterTagsPtrOutput {
	return o.ApplyT(func(v TagsFilter) *TagsFilterTags { return v.Tags }).(TagsFilterTagsPtrOutput)
}

type TagsFilterPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilter)(nil)).Elem()
}

func (o TagsFilterPtrOutput) ToTagsFilterPtrOutput() TagsFilterPtrOutput {
	return o
}

func (o TagsFilterPtrOutput) ToTagsFilterPtrOutputWithContext(ctx context.Context) TagsFilterPtrOutput {
	return o
}

func (o TagsFilterPtrOutput) Elem() TagsFilterOutput {
	return o.ApplyT(func(v *TagsFilter) TagsFilter {
		if v != nil {
			return *v
		}
		var ret TagsFilter
		return ret
	}).(TagsFilterOutput)
}

// Return results that match both `Dimension` objects.
func (o TagsFilterPtrOutput) Ands() TagsFilterAndArrayOutput {
	return o.ApplyT(func(v *TagsFilter) []TagsFilterAnd {
		if v == nil {
			return nil
		}
		return v.Ands
	}).(TagsFilterAndArrayOutput)
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o TagsFilterPtrOutput) CostCategory() TagsFilterCostCategoryPtrOutput {
	return o.ApplyT(func(v *TagsFilter) *TagsFilterCostCategory {
		if v == nil {
			return nil
		}
		return v.CostCategory
	}).(TagsFilterCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o TagsFilterPtrOutput) Dimension() TagsFilterDimensionPtrOutput {
	return o.ApplyT(func(v *TagsFilter) *TagsFilterDimension {
		if v == nil {
			return nil
		}
		return v.Dimension
	}).(TagsFilterDimensionPtrOutput)
}

// Return results that match both `Dimension` object.
func (o TagsFilterPtrOutput) Not() TagsFilterNotPtrOutput {
	return o.ApplyT(func(v *TagsFilter) *TagsFilterNot {
		if v == nil {
			return nil
		}
		return v.Not
	}).(TagsFilterNotPtrOutput)
}

// Return results that match both `Dimension` object.
func (o TagsFilterPtrOutput) Ors() TagsFilterOrArrayOutput {
	return o.ApplyT(func(v *TagsFilter) []TagsFilterOr {
		if v == nil {
			return nil
		}
		return v.Ors
	}).(TagsFilterOrArrayOutput)
}

// Tags that match your request.
func (o TagsFilterPtrOutput) Tags() TagsFilterTagsPtrOutput {
	return o.ApplyT(func(v *TagsFilter) *TagsFilterTags {
		if v == nil {
			return nil
		}
		return v.Tags
	}).(TagsFilterTagsPtrOutput)
}

type TagsFilterAnd struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory *TagsFilterAndCostCategory `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension *TagsFilterAndDimension `pulumi:"dimension"`
	// Tags that match your request.
	Tags *TagsFilterAndTags `pulumi:"tags"`
}

// TagsFilterAndInput is an input type that accepts TagsFilterAndArgs and TagsFilterAndOutput values.
// You can construct a concrete instance of `TagsFilterAndInput` via:
//
//          TagsFilterAndArgs{...}
type TagsFilterAndInput interface {
	pulumi.Input

	ToTagsFilterAndOutput() TagsFilterAndOutput
	ToTagsFilterAndOutputWithContext(context.Context) TagsFilterAndOutput
}

type TagsFilterAndArgs struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory TagsFilterAndCostCategoryPtrInput `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension TagsFilterAndDimensionPtrInput `pulumi:"dimension"`
	// Tags that match your request.
	Tags TagsFilterAndTagsPtrInput `pulumi:"tags"`
}

func (TagsFilterAndArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterAnd)(nil)).Elem()
}

func (i TagsFilterAndArgs) ToTagsFilterAndOutput() TagsFilterAndOutput {
	return i.ToTagsFilterAndOutputWithContext(context.Background())
}

func (i TagsFilterAndArgs) ToTagsFilterAndOutputWithContext(ctx context.Context) TagsFilterAndOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterAndOutput)
}

// TagsFilterAndArrayInput is an input type that accepts TagsFilterAndArray and TagsFilterAndArrayOutput values.
// You can construct a concrete instance of `TagsFilterAndArrayInput` via:
//
//          TagsFilterAndArray{ TagsFilterAndArgs{...} }
type TagsFilterAndArrayInput interface {
	pulumi.Input

	ToTagsFilterAndArrayOutput() TagsFilterAndArrayOutput
	ToTagsFilterAndArrayOutputWithContext(context.Context) TagsFilterAndArrayOutput
}

type TagsFilterAndArray []TagsFilterAndInput

func (TagsFilterAndArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TagsFilterAnd)(nil)).Elem()
}

func (i TagsFilterAndArray) ToTagsFilterAndArrayOutput() TagsFilterAndArrayOutput {
	return i.ToTagsFilterAndArrayOutputWithContext(context.Background())
}

func (i TagsFilterAndArray) ToTagsFilterAndArrayOutputWithContext(ctx context.Context) TagsFilterAndArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterAndArrayOutput)
}

type TagsFilterAndOutput struct{ *pulumi.OutputState }

func (TagsFilterAndOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterAnd)(nil)).Elem()
}

func (o TagsFilterAndOutput) ToTagsFilterAndOutput() TagsFilterAndOutput {
	return o
}

func (o TagsFilterAndOutput) ToTagsFilterAndOutputWithContext(ctx context.Context) TagsFilterAndOutput {
	return o
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o TagsFilterAndOutput) CostCategory() TagsFilterAndCostCategoryPtrOutput {
	return o.ApplyT(func(v TagsFilterAnd) *TagsFilterAndCostCategory { return v.CostCategory }).(TagsFilterAndCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o TagsFilterAndOutput) Dimension() TagsFilterAndDimensionPtrOutput {
	return o.ApplyT(func(v TagsFilterAnd) *TagsFilterAndDimension { return v.Dimension }).(TagsFilterAndDimensionPtrOutput)
}

// Tags that match your request.
func (o TagsFilterAndOutput) Tags() TagsFilterAndTagsPtrOutput {
	return o.ApplyT(func(v TagsFilterAnd) *TagsFilterAndTags { return v.Tags }).(TagsFilterAndTagsPtrOutput)
}

type TagsFilterAndArrayOutput struct{ *pulumi.OutputState }

func (TagsFilterAndArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TagsFilterAnd)(nil)).Elem()
}

func (o TagsFilterAndArrayOutput) ToTagsFilterAndArrayOutput() TagsFilterAndArrayOutput {
	return o
}

func (o TagsFilterAndArrayOutput) ToTagsFilterAndArrayOutputWithContext(ctx context.Context) TagsFilterAndArrayOutput {
	return o
}

func (o TagsFilterAndArrayOutput) Index(i pulumi.IntInput) TagsFilterAndOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TagsFilterAnd {
		return vs[0].([]TagsFilterAnd)[vs[1].(int)]
	}).(TagsFilterAndOutput)
}

type TagsFilterAndCostCategory struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterAndCostCategoryInput is an input type that accepts TagsFilterAndCostCategoryArgs and TagsFilterAndCostCategoryOutput values.
// You can construct a concrete instance of `TagsFilterAndCostCategoryInput` via:
//
//          TagsFilterAndCostCategoryArgs{...}
type TagsFilterAndCostCategoryInput interface {
	pulumi.Input

	ToTagsFilterAndCostCategoryOutput() TagsFilterAndCostCategoryOutput
	ToTagsFilterAndCostCategoryOutputWithContext(context.Context) TagsFilterAndCostCategoryOutput
}

type TagsFilterAndCostCategoryArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterAndCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterAndCostCategory)(nil)).Elem()
}

func (i TagsFilterAndCostCategoryArgs) ToTagsFilterAndCostCategoryOutput() TagsFilterAndCostCategoryOutput {
	return i.ToTagsFilterAndCostCategoryOutputWithContext(context.Background())
}

func (i TagsFilterAndCostCategoryArgs) ToTagsFilterAndCostCategoryOutputWithContext(ctx context.Context) TagsFilterAndCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterAndCostCategoryOutput)
}

func (i TagsFilterAndCostCategoryArgs) ToTagsFilterAndCostCategoryPtrOutput() TagsFilterAndCostCategoryPtrOutput {
	return i.ToTagsFilterAndCostCategoryPtrOutputWithContext(context.Background())
}

func (i TagsFilterAndCostCategoryArgs) ToTagsFilterAndCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterAndCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterAndCostCategoryOutput).ToTagsFilterAndCostCategoryPtrOutputWithContext(ctx)
}

// TagsFilterAndCostCategoryPtrInput is an input type that accepts TagsFilterAndCostCategoryArgs, TagsFilterAndCostCategoryPtr and TagsFilterAndCostCategoryPtrOutput values.
// You can construct a concrete instance of `TagsFilterAndCostCategoryPtrInput` via:
//
//          TagsFilterAndCostCategoryArgs{...}
//
//  or:
//
//          nil
type TagsFilterAndCostCategoryPtrInput interface {
	pulumi.Input

	ToTagsFilterAndCostCategoryPtrOutput() TagsFilterAndCostCategoryPtrOutput
	ToTagsFilterAndCostCategoryPtrOutputWithContext(context.Context) TagsFilterAndCostCategoryPtrOutput
}

type tagsFilterAndCostCategoryPtrType TagsFilterAndCostCategoryArgs

func TagsFilterAndCostCategoryPtr(v *TagsFilterAndCostCategoryArgs) TagsFilterAndCostCategoryPtrInput {
	return (*tagsFilterAndCostCategoryPtrType)(v)
}

func (*tagsFilterAndCostCategoryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterAndCostCategory)(nil)).Elem()
}

func (i *tagsFilterAndCostCategoryPtrType) ToTagsFilterAndCostCategoryPtrOutput() TagsFilterAndCostCategoryPtrOutput {
	return i.ToTagsFilterAndCostCategoryPtrOutputWithContext(context.Background())
}

func (i *tagsFilterAndCostCategoryPtrType) ToTagsFilterAndCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterAndCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterAndCostCategoryPtrOutput)
}

type TagsFilterAndCostCategoryOutput struct{ *pulumi.OutputState }

func (TagsFilterAndCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterAndCostCategory)(nil)).Elem()
}

func (o TagsFilterAndCostCategoryOutput) ToTagsFilterAndCostCategoryOutput() TagsFilterAndCostCategoryOutput {
	return o
}

func (o TagsFilterAndCostCategoryOutput) ToTagsFilterAndCostCategoryOutputWithContext(ctx context.Context) TagsFilterAndCostCategoryOutput {
	return o
}

func (o TagsFilterAndCostCategoryOutput) ToTagsFilterAndCostCategoryPtrOutput() TagsFilterAndCostCategoryPtrOutput {
	return o.ToTagsFilterAndCostCategoryPtrOutputWithContext(context.Background())
}

func (o TagsFilterAndCostCategoryOutput) ToTagsFilterAndCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterAndCostCategoryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterAndCostCategory) *TagsFilterAndCostCategory {
		return &v
	}).(TagsFilterAndCostCategoryPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterAndCostCategoryOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterAndCostCategory) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterAndCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterAndCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterAndCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterAndCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterAndCostCategoryPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterAndCostCategoryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterAndCostCategory)(nil)).Elem()
}

func (o TagsFilterAndCostCategoryPtrOutput) ToTagsFilterAndCostCategoryPtrOutput() TagsFilterAndCostCategoryPtrOutput {
	return o
}

func (o TagsFilterAndCostCategoryPtrOutput) ToTagsFilterAndCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterAndCostCategoryPtrOutput {
	return o
}

func (o TagsFilterAndCostCategoryPtrOutput) Elem() TagsFilterAndCostCategoryOutput {
	return o.ApplyT(func(v *TagsFilterAndCostCategory) TagsFilterAndCostCategory {
		if v != nil {
			return *v
		}
		var ret TagsFilterAndCostCategory
		return ret
	}).(TagsFilterAndCostCategoryOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterAndCostCategoryPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterAndCostCategory) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterAndCostCategoryPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterAndCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterAndCostCategoryPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterAndCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsFilterAndDimension struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterAndDimensionInput is an input type that accepts TagsFilterAndDimensionArgs and TagsFilterAndDimensionOutput values.
// You can construct a concrete instance of `TagsFilterAndDimensionInput` via:
//
//          TagsFilterAndDimensionArgs{...}
type TagsFilterAndDimensionInput interface {
	pulumi.Input

	ToTagsFilterAndDimensionOutput() TagsFilterAndDimensionOutput
	ToTagsFilterAndDimensionOutputWithContext(context.Context) TagsFilterAndDimensionOutput
}

type TagsFilterAndDimensionArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterAndDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterAndDimension)(nil)).Elem()
}

func (i TagsFilterAndDimensionArgs) ToTagsFilterAndDimensionOutput() TagsFilterAndDimensionOutput {
	return i.ToTagsFilterAndDimensionOutputWithContext(context.Background())
}

func (i TagsFilterAndDimensionArgs) ToTagsFilterAndDimensionOutputWithContext(ctx context.Context) TagsFilterAndDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterAndDimensionOutput)
}

func (i TagsFilterAndDimensionArgs) ToTagsFilterAndDimensionPtrOutput() TagsFilterAndDimensionPtrOutput {
	return i.ToTagsFilterAndDimensionPtrOutputWithContext(context.Background())
}

func (i TagsFilterAndDimensionArgs) ToTagsFilterAndDimensionPtrOutputWithContext(ctx context.Context) TagsFilterAndDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterAndDimensionOutput).ToTagsFilterAndDimensionPtrOutputWithContext(ctx)
}

// TagsFilterAndDimensionPtrInput is an input type that accepts TagsFilterAndDimensionArgs, TagsFilterAndDimensionPtr and TagsFilterAndDimensionPtrOutput values.
// You can construct a concrete instance of `TagsFilterAndDimensionPtrInput` via:
//
//          TagsFilterAndDimensionArgs{...}
//
//  or:
//
//          nil
type TagsFilterAndDimensionPtrInput interface {
	pulumi.Input

	ToTagsFilterAndDimensionPtrOutput() TagsFilterAndDimensionPtrOutput
	ToTagsFilterAndDimensionPtrOutputWithContext(context.Context) TagsFilterAndDimensionPtrOutput
}

type tagsFilterAndDimensionPtrType TagsFilterAndDimensionArgs

func TagsFilterAndDimensionPtr(v *TagsFilterAndDimensionArgs) TagsFilterAndDimensionPtrInput {
	return (*tagsFilterAndDimensionPtrType)(v)
}

func (*tagsFilterAndDimensionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterAndDimension)(nil)).Elem()
}

func (i *tagsFilterAndDimensionPtrType) ToTagsFilterAndDimensionPtrOutput() TagsFilterAndDimensionPtrOutput {
	return i.ToTagsFilterAndDimensionPtrOutputWithContext(context.Background())
}

func (i *tagsFilterAndDimensionPtrType) ToTagsFilterAndDimensionPtrOutputWithContext(ctx context.Context) TagsFilterAndDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterAndDimensionPtrOutput)
}

type TagsFilterAndDimensionOutput struct{ *pulumi.OutputState }

func (TagsFilterAndDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterAndDimension)(nil)).Elem()
}

func (o TagsFilterAndDimensionOutput) ToTagsFilterAndDimensionOutput() TagsFilterAndDimensionOutput {
	return o
}

func (o TagsFilterAndDimensionOutput) ToTagsFilterAndDimensionOutputWithContext(ctx context.Context) TagsFilterAndDimensionOutput {
	return o
}

func (o TagsFilterAndDimensionOutput) ToTagsFilterAndDimensionPtrOutput() TagsFilterAndDimensionPtrOutput {
	return o.ToTagsFilterAndDimensionPtrOutputWithContext(context.Background())
}

func (o TagsFilterAndDimensionOutput) ToTagsFilterAndDimensionPtrOutputWithContext(ctx context.Context) TagsFilterAndDimensionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterAndDimension) *TagsFilterAndDimension {
		return &v
	}).(TagsFilterAndDimensionPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterAndDimensionOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterAndDimension) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterAndDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterAndDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterAndDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterAndDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterAndDimensionPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterAndDimensionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterAndDimension)(nil)).Elem()
}

func (o TagsFilterAndDimensionPtrOutput) ToTagsFilterAndDimensionPtrOutput() TagsFilterAndDimensionPtrOutput {
	return o
}

func (o TagsFilterAndDimensionPtrOutput) ToTagsFilterAndDimensionPtrOutputWithContext(ctx context.Context) TagsFilterAndDimensionPtrOutput {
	return o
}

func (o TagsFilterAndDimensionPtrOutput) Elem() TagsFilterAndDimensionOutput {
	return o.ApplyT(func(v *TagsFilterAndDimension) TagsFilterAndDimension {
		if v != nil {
			return *v
		}
		var ret TagsFilterAndDimension
		return ret
	}).(TagsFilterAndDimensionOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterAndDimensionPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterAndDimension) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterAndDimensionPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterAndDimension) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterAndDimensionPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterAndDimension) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsFilterAndTags struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterAndTagsInput is an input type that accepts TagsFilterAndTagsArgs and TagsFilterAndTagsOutput values.
// You can construct a concrete instance of `TagsFilterAndTagsInput` via:
//
//          TagsFilterAndTagsArgs{...}
type TagsFilterAndTagsInput interface {
	pulumi.Input

	ToTagsFilterAndTagsOutput() TagsFilterAndTagsOutput
	ToTagsFilterAndTagsOutputWithContext(context.Context) TagsFilterAndTagsOutput
}

type TagsFilterAndTagsArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterAndTagsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterAndTags)(nil)).Elem()
}

func (i TagsFilterAndTagsArgs) ToTagsFilterAndTagsOutput() TagsFilterAndTagsOutput {
	return i.ToTagsFilterAndTagsOutputWithContext(context.Background())
}

func (i TagsFilterAndTagsArgs) ToTagsFilterAndTagsOutputWithContext(ctx context.Context) TagsFilterAndTagsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterAndTagsOutput)
}

func (i TagsFilterAndTagsArgs) ToTagsFilterAndTagsPtrOutput() TagsFilterAndTagsPtrOutput {
	return i.ToTagsFilterAndTagsPtrOutputWithContext(context.Background())
}

func (i TagsFilterAndTagsArgs) ToTagsFilterAndTagsPtrOutputWithContext(ctx context.Context) TagsFilterAndTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterAndTagsOutput).ToTagsFilterAndTagsPtrOutputWithContext(ctx)
}

// TagsFilterAndTagsPtrInput is an input type that accepts TagsFilterAndTagsArgs, TagsFilterAndTagsPtr and TagsFilterAndTagsPtrOutput values.
// You can construct a concrete instance of `TagsFilterAndTagsPtrInput` via:
//
//          TagsFilterAndTagsArgs{...}
//
//  or:
//
//          nil
type TagsFilterAndTagsPtrInput interface {
	pulumi.Input

	ToTagsFilterAndTagsPtrOutput() TagsFilterAndTagsPtrOutput
	ToTagsFilterAndTagsPtrOutputWithContext(context.Context) TagsFilterAndTagsPtrOutput
}

type tagsFilterAndTagsPtrType TagsFilterAndTagsArgs

func TagsFilterAndTagsPtr(v *TagsFilterAndTagsArgs) TagsFilterAndTagsPtrInput {
	return (*tagsFilterAndTagsPtrType)(v)
}

func (*tagsFilterAndTagsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterAndTags)(nil)).Elem()
}

func (i *tagsFilterAndTagsPtrType) ToTagsFilterAndTagsPtrOutput() TagsFilterAndTagsPtrOutput {
	return i.ToTagsFilterAndTagsPtrOutputWithContext(context.Background())
}

func (i *tagsFilterAndTagsPtrType) ToTagsFilterAndTagsPtrOutputWithContext(ctx context.Context) TagsFilterAndTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterAndTagsPtrOutput)
}

type TagsFilterAndTagsOutput struct{ *pulumi.OutputState }

func (TagsFilterAndTagsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterAndTags)(nil)).Elem()
}

func (o TagsFilterAndTagsOutput) ToTagsFilterAndTagsOutput() TagsFilterAndTagsOutput {
	return o
}

func (o TagsFilterAndTagsOutput) ToTagsFilterAndTagsOutputWithContext(ctx context.Context) TagsFilterAndTagsOutput {
	return o
}

func (o TagsFilterAndTagsOutput) ToTagsFilterAndTagsPtrOutput() TagsFilterAndTagsPtrOutput {
	return o.ToTagsFilterAndTagsPtrOutputWithContext(context.Background())
}

func (o TagsFilterAndTagsOutput) ToTagsFilterAndTagsPtrOutputWithContext(ctx context.Context) TagsFilterAndTagsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterAndTags) *TagsFilterAndTags {
		return &v
	}).(TagsFilterAndTagsPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterAndTagsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterAndTags) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterAndTagsOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterAndTags) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterAndTagsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterAndTags) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterAndTagsPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterAndTagsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterAndTags)(nil)).Elem()
}

func (o TagsFilterAndTagsPtrOutput) ToTagsFilterAndTagsPtrOutput() TagsFilterAndTagsPtrOutput {
	return o
}

func (o TagsFilterAndTagsPtrOutput) ToTagsFilterAndTagsPtrOutputWithContext(ctx context.Context) TagsFilterAndTagsPtrOutput {
	return o
}

func (o TagsFilterAndTagsPtrOutput) Elem() TagsFilterAndTagsOutput {
	return o.ApplyT(func(v *TagsFilterAndTags) TagsFilterAndTags {
		if v != nil {
			return *v
		}
		var ret TagsFilterAndTags
		return ret
	}).(TagsFilterAndTagsOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterAndTagsPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterAndTags) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterAndTagsPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterAndTags) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterAndTagsPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterAndTags) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsFilterCostCategory struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterCostCategoryInput is an input type that accepts TagsFilterCostCategoryArgs and TagsFilterCostCategoryOutput values.
// You can construct a concrete instance of `TagsFilterCostCategoryInput` via:
//
//          TagsFilterCostCategoryArgs{...}
type TagsFilterCostCategoryInput interface {
	pulumi.Input

	ToTagsFilterCostCategoryOutput() TagsFilterCostCategoryOutput
	ToTagsFilterCostCategoryOutputWithContext(context.Context) TagsFilterCostCategoryOutput
}

type TagsFilterCostCategoryArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterCostCategory)(nil)).Elem()
}

func (i TagsFilterCostCategoryArgs) ToTagsFilterCostCategoryOutput() TagsFilterCostCategoryOutput {
	return i.ToTagsFilterCostCategoryOutputWithContext(context.Background())
}

func (i TagsFilterCostCategoryArgs) ToTagsFilterCostCategoryOutputWithContext(ctx context.Context) TagsFilterCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterCostCategoryOutput)
}

func (i TagsFilterCostCategoryArgs) ToTagsFilterCostCategoryPtrOutput() TagsFilterCostCategoryPtrOutput {
	return i.ToTagsFilterCostCategoryPtrOutputWithContext(context.Background())
}

func (i TagsFilterCostCategoryArgs) ToTagsFilterCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterCostCategoryOutput).ToTagsFilterCostCategoryPtrOutputWithContext(ctx)
}

// TagsFilterCostCategoryPtrInput is an input type that accepts TagsFilterCostCategoryArgs, TagsFilterCostCategoryPtr and TagsFilterCostCategoryPtrOutput values.
// You can construct a concrete instance of `TagsFilterCostCategoryPtrInput` via:
//
//          TagsFilterCostCategoryArgs{...}
//
//  or:
//
//          nil
type TagsFilterCostCategoryPtrInput interface {
	pulumi.Input

	ToTagsFilterCostCategoryPtrOutput() TagsFilterCostCategoryPtrOutput
	ToTagsFilterCostCategoryPtrOutputWithContext(context.Context) TagsFilterCostCategoryPtrOutput
}

type tagsFilterCostCategoryPtrType TagsFilterCostCategoryArgs

func TagsFilterCostCategoryPtr(v *TagsFilterCostCategoryArgs) TagsFilterCostCategoryPtrInput {
	return (*tagsFilterCostCategoryPtrType)(v)
}

func (*tagsFilterCostCategoryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterCostCategory)(nil)).Elem()
}

func (i *tagsFilterCostCategoryPtrType) ToTagsFilterCostCategoryPtrOutput() TagsFilterCostCategoryPtrOutput {
	return i.ToTagsFilterCostCategoryPtrOutputWithContext(context.Background())
}

func (i *tagsFilterCostCategoryPtrType) ToTagsFilterCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterCostCategoryPtrOutput)
}

type TagsFilterCostCategoryOutput struct{ *pulumi.OutputState }

func (TagsFilterCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterCostCategory)(nil)).Elem()
}

func (o TagsFilterCostCategoryOutput) ToTagsFilterCostCategoryOutput() TagsFilterCostCategoryOutput {
	return o
}

func (o TagsFilterCostCategoryOutput) ToTagsFilterCostCategoryOutputWithContext(ctx context.Context) TagsFilterCostCategoryOutput {
	return o
}

func (o TagsFilterCostCategoryOutput) ToTagsFilterCostCategoryPtrOutput() TagsFilterCostCategoryPtrOutput {
	return o.ToTagsFilterCostCategoryPtrOutputWithContext(context.Background())
}

func (o TagsFilterCostCategoryOutput) ToTagsFilterCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterCostCategoryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterCostCategory) *TagsFilterCostCategory {
		return &v
	}).(TagsFilterCostCategoryPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterCostCategoryOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterCostCategory) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterCostCategoryPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterCostCategoryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterCostCategory)(nil)).Elem()
}

func (o TagsFilterCostCategoryPtrOutput) ToTagsFilterCostCategoryPtrOutput() TagsFilterCostCategoryPtrOutput {
	return o
}

func (o TagsFilterCostCategoryPtrOutput) ToTagsFilterCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterCostCategoryPtrOutput {
	return o
}

func (o TagsFilterCostCategoryPtrOutput) Elem() TagsFilterCostCategoryOutput {
	return o.ApplyT(func(v *TagsFilterCostCategory) TagsFilterCostCategory {
		if v != nil {
			return *v
		}
		var ret TagsFilterCostCategory
		return ret
	}).(TagsFilterCostCategoryOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterCostCategoryPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterCostCategory) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterCostCategoryPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterCostCategoryPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsFilterDimension struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterDimensionInput is an input type that accepts TagsFilterDimensionArgs and TagsFilterDimensionOutput values.
// You can construct a concrete instance of `TagsFilterDimensionInput` via:
//
//          TagsFilterDimensionArgs{...}
type TagsFilterDimensionInput interface {
	pulumi.Input

	ToTagsFilterDimensionOutput() TagsFilterDimensionOutput
	ToTagsFilterDimensionOutputWithContext(context.Context) TagsFilterDimensionOutput
}

type TagsFilterDimensionArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterDimension)(nil)).Elem()
}

func (i TagsFilterDimensionArgs) ToTagsFilterDimensionOutput() TagsFilterDimensionOutput {
	return i.ToTagsFilterDimensionOutputWithContext(context.Background())
}

func (i TagsFilterDimensionArgs) ToTagsFilterDimensionOutputWithContext(ctx context.Context) TagsFilterDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterDimensionOutput)
}

func (i TagsFilterDimensionArgs) ToTagsFilterDimensionPtrOutput() TagsFilterDimensionPtrOutput {
	return i.ToTagsFilterDimensionPtrOutputWithContext(context.Background())
}

func (i TagsFilterDimensionArgs) ToTagsFilterDimensionPtrOutputWithContext(ctx context.Context) TagsFilterDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterDimensionOutput).ToTagsFilterDimensionPtrOutputWithContext(ctx)
}

// TagsFilterDimensionPtrInput is an input type that accepts TagsFilterDimensionArgs, TagsFilterDimensionPtr and TagsFilterDimensionPtrOutput values.
// You can construct a concrete instance of `TagsFilterDimensionPtrInput` via:
//
//          TagsFilterDimensionArgs{...}
//
//  or:
//
//          nil
type TagsFilterDimensionPtrInput interface {
	pulumi.Input

	ToTagsFilterDimensionPtrOutput() TagsFilterDimensionPtrOutput
	ToTagsFilterDimensionPtrOutputWithContext(context.Context) TagsFilterDimensionPtrOutput
}

type tagsFilterDimensionPtrType TagsFilterDimensionArgs

func TagsFilterDimensionPtr(v *TagsFilterDimensionArgs) TagsFilterDimensionPtrInput {
	return (*tagsFilterDimensionPtrType)(v)
}

func (*tagsFilterDimensionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterDimension)(nil)).Elem()
}

func (i *tagsFilterDimensionPtrType) ToTagsFilterDimensionPtrOutput() TagsFilterDimensionPtrOutput {
	return i.ToTagsFilterDimensionPtrOutputWithContext(context.Background())
}

func (i *tagsFilterDimensionPtrType) ToTagsFilterDimensionPtrOutputWithContext(ctx context.Context) TagsFilterDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterDimensionPtrOutput)
}

type TagsFilterDimensionOutput struct{ *pulumi.OutputState }

func (TagsFilterDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterDimension)(nil)).Elem()
}

func (o TagsFilterDimensionOutput) ToTagsFilterDimensionOutput() TagsFilterDimensionOutput {
	return o
}

func (o TagsFilterDimensionOutput) ToTagsFilterDimensionOutputWithContext(ctx context.Context) TagsFilterDimensionOutput {
	return o
}

func (o TagsFilterDimensionOutput) ToTagsFilterDimensionPtrOutput() TagsFilterDimensionPtrOutput {
	return o.ToTagsFilterDimensionPtrOutputWithContext(context.Background())
}

func (o TagsFilterDimensionOutput) ToTagsFilterDimensionPtrOutputWithContext(ctx context.Context) TagsFilterDimensionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterDimension) *TagsFilterDimension {
		return &v
	}).(TagsFilterDimensionPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterDimensionOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterDimension) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterDimensionPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterDimensionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterDimension)(nil)).Elem()
}

func (o TagsFilterDimensionPtrOutput) ToTagsFilterDimensionPtrOutput() TagsFilterDimensionPtrOutput {
	return o
}

func (o TagsFilterDimensionPtrOutput) ToTagsFilterDimensionPtrOutputWithContext(ctx context.Context) TagsFilterDimensionPtrOutput {
	return o
}

func (o TagsFilterDimensionPtrOutput) Elem() TagsFilterDimensionOutput {
	return o.ApplyT(func(v *TagsFilterDimension) TagsFilterDimension {
		if v != nil {
			return *v
		}
		var ret TagsFilterDimension
		return ret
	}).(TagsFilterDimensionOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterDimensionPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterDimension) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterDimensionPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterDimension) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterDimensionPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterDimension) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsFilterNot struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory *TagsFilterNotCostCategory `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension *TagsFilterNotDimension `pulumi:"dimension"`
	// Tags that match your request.
	Tags *TagsFilterNotTags `pulumi:"tags"`
}

// TagsFilterNotInput is an input type that accepts TagsFilterNotArgs and TagsFilterNotOutput values.
// You can construct a concrete instance of `TagsFilterNotInput` via:
//
//          TagsFilterNotArgs{...}
type TagsFilterNotInput interface {
	pulumi.Input

	ToTagsFilterNotOutput() TagsFilterNotOutput
	ToTagsFilterNotOutputWithContext(context.Context) TagsFilterNotOutput
}

type TagsFilterNotArgs struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory TagsFilterNotCostCategoryPtrInput `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension TagsFilterNotDimensionPtrInput `pulumi:"dimension"`
	// Tags that match your request.
	Tags TagsFilterNotTagsPtrInput `pulumi:"tags"`
}

func (TagsFilterNotArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterNot)(nil)).Elem()
}

func (i TagsFilterNotArgs) ToTagsFilterNotOutput() TagsFilterNotOutput {
	return i.ToTagsFilterNotOutputWithContext(context.Background())
}

func (i TagsFilterNotArgs) ToTagsFilterNotOutputWithContext(ctx context.Context) TagsFilterNotOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotOutput)
}

func (i TagsFilterNotArgs) ToTagsFilterNotPtrOutput() TagsFilterNotPtrOutput {
	return i.ToTagsFilterNotPtrOutputWithContext(context.Background())
}

func (i TagsFilterNotArgs) ToTagsFilterNotPtrOutputWithContext(ctx context.Context) TagsFilterNotPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotOutput).ToTagsFilterNotPtrOutputWithContext(ctx)
}

// TagsFilterNotPtrInput is an input type that accepts TagsFilterNotArgs, TagsFilterNotPtr and TagsFilterNotPtrOutput values.
// You can construct a concrete instance of `TagsFilterNotPtrInput` via:
//
//          TagsFilterNotArgs{...}
//
//  or:
//
//          nil
type TagsFilterNotPtrInput interface {
	pulumi.Input

	ToTagsFilterNotPtrOutput() TagsFilterNotPtrOutput
	ToTagsFilterNotPtrOutputWithContext(context.Context) TagsFilterNotPtrOutput
}

type tagsFilterNotPtrType TagsFilterNotArgs

func TagsFilterNotPtr(v *TagsFilterNotArgs) TagsFilterNotPtrInput {
	return (*tagsFilterNotPtrType)(v)
}

func (*tagsFilterNotPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterNot)(nil)).Elem()
}

func (i *tagsFilterNotPtrType) ToTagsFilterNotPtrOutput() TagsFilterNotPtrOutput {
	return i.ToTagsFilterNotPtrOutputWithContext(context.Background())
}

func (i *tagsFilterNotPtrType) ToTagsFilterNotPtrOutputWithContext(ctx context.Context) TagsFilterNotPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotPtrOutput)
}

type TagsFilterNotOutput struct{ *pulumi.OutputState }

func (TagsFilterNotOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterNot)(nil)).Elem()
}

func (o TagsFilterNotOutput) ToTagsFilterNotOutput() TagsFilterNotOutput {
	return o
}

func (o TagsFilterNotOutput) ToTagsFilterNotOutputWithContext(ctx context.Context) TagsFilterNotOutput {
	return o
}

func (o TagsFilterNotOutput) ToTagsFilterNotPtrOutput() TagsFilterNotPtrOutput {
	return o.ToTagsFilterNotPtrOutputWithContext(context.Background())
}

func (o TagsFilterNotOutput) ToTagsFilterNotPtrOutputWithContext(ctx context.Context) TagsFilterNotPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterNot) *TagsFilterNot {
		return &v
	}).(TagsFilterNotPtrOutput)
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o TagsFilterNotOutput) CostCategory() TagsFilterNotCostCategoryPtrOutput {
	return o.ApplyT(func(v TagsFilterNot) *TagsFilterNotCostCategory { return v.CostCategory }).(TagsFilterNotCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o TagsFilterNotOutput) Dimension() TagsFilterNotDimensionPtrOutput {
	return o.ApplyT(func(v TagsFilterNot) *TagsFilterNotDimension { return v.Dimension }).(TagsFilterNotDimensionPtrOutput)
}

// Tags that match your request.
func (o TagsFilterNotOutput) Tags() TagsFilterNotTagsPtrOutput {
	return o.ApplyT(func(v TagsFilterNot) *TagsFilterNotTags { return v.Tags }).(TagsFilterNotTagsPtrOutput)
}

type TagsFilterNotPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterNotPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterNot)(nil)).Elem()
}

func (o TagsFilterNotPtrOutput) ToTagsFilterNotPtrOutput() TagsFilterNotPtrOutput {
	return o
}

func (o TagsFilterNotPtrOutput) ToTagsFilterNotPtrOutputWithContext(ctx context.Context) TagsFilterNotPtrOutput {
	return o
}

func (o TagsFilterNotPtrOutput) Elem() TagsFilterNotOutput {
	return o.ApplyT(func(v *TagsFilterNot) TagsFilterNot {
		if v != nil {
			return *v
		}
		var ret TagsFilterNot
		return ret
	}).(TagsFilterNotOutput)
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o TagsFilterNotPtrOutput) CostCategory() TagsFilterNotCostCategoryPtrOutput {
	return o.ApplyT(func(v *TagsFilterNot) *TagsFilterNotCostCategory {
		if v == nil {
			return nil
		}
		return v.CostCategory
	}).(TagsFilterNotCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o TagsFilterNotPtrOutput) Dimension() TagsFilterNotDimensionPtrOutput {
	return o.ApplyT(func(v *TagsFilterNot) *TagsFilterNotDimension {
		if v == nil {
			return nil
		}
		return v.Dimension
	}).(TagsFilterNotDimensionPtrOutput)
}

// Tags that match your request.
func (o TagsFilterNotPtrOutput) Tags() TagsFilterNotTagsPtrOutput {
	return o.ApplyT(func(v *TagsFilterNot) *TagsFilterNotTags {
		if v == nil {
			return nil
		}
		return v.Tags
	}).(TagsFilterNotTagsPtrOutput)
}

type TagsFilterNotCostCategory struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterNotCostCategoryInput is an input type that accepts TagsFilterNotCostCategoryArgs and TagsFilterNotCostCategoryOutput values.
// You can construct a concrete instance of `TagsFilterNotCostCategoryInput` via:
//
//          TagsFilterNotCostCategoryArgs{...}
type TagsFilterNotCostCategoryInput interface {
	pulumi.Input

	ToTagsFilterNotCostCategoryOutput() TagsFilterNotCostCategoryOutput
	ToTagsFilterNotCostCategoryOutputWithContext(context.Context) TagsFilterNotCostCategoryOutput
}

type TagsFilterNotCostCategoryArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterNotCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterNotCostCategory)(nil)).Elem()
}

func (i TagsFilterNotCostCategoryArgs) ToTagsFilterNotCostCategoryOutput() TagsFilterNotCostCategoryOutput {
	return i.ToTagsFilterNotCostCategoryOutputWithContext(context.Background())
}

func (i TagsFilterNotCostCategoryArgs) ToTagsFilterNotCostCategoryOutputWithContext(ctx context.Context) TagsFilterNotCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotCostCategoryOutput)
}

func (i TagsFilterNotCostCategoryArgs) ToTagsFilterNotCostCategoryPtrOutput() TagsFilterNotCostCategoryPtrOutput {
	return i.ToTagsFilterNotCostCategoryPtrOutputWithContext(context.Background())
}

func (i TagsFilterNotCostCategoryArgs) ToTagsFilterNotCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterNotCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotCostCategoryOutput).ToTagsFilterNotCostCategoryPtrOutputWithContext(ctx)
}

// TagsFilterNotCostCategoryPtrInput is an input type that accepts TagsFilterNotCostCategoryArgs, TagsFilterNotCostCategoryPtr and TagsFilterNotCostCategoryPtrOutput values.
// You can construct a concrete instance of `TagsFilterNotCostCategoryPtrInput` via:
//
//          TagsFilterNotCostCategoryArgs{...}
//
//  or:
//
//          nil
type TagsFilterNotCostCategoryPtrInput interface {
	pulumi.Input

	ToTagsFilterNotCostCategoryPtrOutput() TagsFilterNotCostCategoryPtrOutput
	ToTagsFilterNotCostCategoryPtrOutputWithContext(context.Context) TagsFilterNotCostCategoryPtrOutput
}

type tagsFilterNotCostCategoryPtrType TagsFilterNotCostCategoryArgs

func TagsFilterNotCostCategoryPtr(v *TagsFilterNotCostCategoryArgs) TagsFilterNotCostCategoryPtrInput {
	return (*tagsFilterNotCostCategoryPtrType)(v)
}

func (*tagsFilterNotCostCategoryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterNotCostCategory)(nil)).Elem()
}

func (i *tagsFilterNotCostCategoryPtrType) ToTagsFilterNotCostCategoryPtrOutput() TagsFilterNotCostCategoryPtrOutput {
	return i.ToTagsFilterNotCostCategoryPtrOutputWithContext(context.Background())
}

func (i *tagsFilterNotCostCategoryPtrType) ToTagsFilterNotCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterNotCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotCostCategoryPtrOutput)
}

type TagsFilterNotCostCategoryOutput struct{ *pulumi.OutputState }

func (TagsFilterNotCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterNotCostCategory)(nil)).Elem()
}

func (o TagsFilterNotCostCategoryOutput) ToTagsFilterNotCostCategoryOutput() TagsFilterNotCostCategoryOutput {
	return o
}

func (o TagsFilterNotCostCategoryOutput) ToTagsFilterNotCostCategoryOutputWithContext(ctx context.Context) TagsFilterNotCostCategoryOutput {
	return o
}

func (o TagsFilterNotCostCategoryOutput) ToTagsFilterNotCostCategoryPtrOutput() TagsFilterNotCostCategoryPtrOutput {
	return o.ToTagsFilterNotCostCategoryPtrOutputWithContext(context.Background())
}

func (o TagsFilterNotCostCategoryOutput) ToTagsFilterNotCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterNotCostCategoryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterNotCostCategory) *TagsFilterNotCostCategory {
		return &v
	}).(TagsFilterNotCostCategoryPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterNotCostCategoryOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterNotCostCategory) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterNotCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterNotCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterNotCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterNotCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterNotCostCategoryPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterNotCostCategoryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterNotCostCategory)(nil)).Elem()
}

func (o TagsFilterNotCostCategoryPtrOutput) ToTagsFilterNotCostCategoryPtrOutput() TagsFilterNotCostCategoryPtrOutput {
	return o
}

func (o TagsFilterNotCostCategoryPtrOutput) ToTagsFilterNotCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterNotCostCategoryPtrOutput {
	return o
}

func (o TagsFilterNotCostCategoryPtrOutput) Elem() TagsFilterNotCostCategoryOutput {
	return o.ApplyT(func(v *TagsFilterNotCostCategory) TagsFilterNotCostCategory {
		if v != nil {
			return *v
		}
		var ret TagsFilterNotCostCategory
		return ret
	}).(TagsFilterNotCostCategoryOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterNotCostCategoryPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterNotCostCategory) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterNotCostCategoryPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterNotCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterNotCostCategoryPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterNotCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsFilterNotDimension struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterNotDimensionInput is an input type that accepts TagsFilterNotDimensionArgs and TagsFilterNotDimensionOutput values.
// You can construct a concrete instance of `TagsFilterNotDimensionInput` via:
//
//          TagsFilterNotDimensionArgs{...}
type TagsFilterNotDimensionInput interface {
	pulumi.Input

	ToTagsFilterNotDimensionOutput() TagsFilterNotDimensionOutput
	ToTagsFilterNotDimensionOutputWithContext(context.Context) TagsFilterNotDimensionOutput
}

type TagsFilterNotDimensionArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterNotDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterNotDimension)(nil)).Elem()
}

func (i TagsFilterNotDimensionArgs) ToTagsFilterNotDimensionOutput() TagsFilterNotDimensionOutput {
	return i.ToTagsFilterNotDimensionOutputWithContext(context.Background())
}

func (i TagsFilterNotDimensionArgs) ToTagsFilterNotDimensionOutputWithContext(ctx context.Context) TagsFilterNotDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotDimensionOutput)
}

func (i TagsFilterNotDimensionArgs) ToTagsFilterNotDimensionPtrOutput() TagsFilterNotDimensionPtrOutput {
	return i.ToTagsFilterNotDimensionPtrOutputWithContext(context.Background())
}

func (i TagsFilterNotDimensionArgs) ToTagsFilterNotDimensionPtrOutputWithContext(ctx context.Context) TagsFilterNotDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotDimensionOutput).ToTagsFilterNotDimensionPtrOutputWithContext(ctx)
}

// TagsFilterNotDimensionPtrInput is an input type that accepts TagsFilterNotDimensionArgs, TagsFilterNotDimensionPtr and TagsFilterNotDimensionPtrOutput values.
// You can construct a concrete instance of `TagsFilterNotDimensionPtrInput` via:
//
//          TagsFilterNotDimensionArgs{...}
//
//  or:
//
//          nil
type TagsFilterNotDimensionPtrInput interface {
	pulumi.Input

	ToTagsFilterNotDimensionPtrOutput() TagsFilterNotDimensionPtrOutput
	ToTagsFilterNotDimensionPtrOutputWithContext(context.Context) TagsFilterNotDimensionPtrOutput
}

type tagsFilterNotDimensionPtrType TagsFilterNotDimensionArgs

func TagsFilterNotDimensionPtr(v *TagsFilterNotDimensionArgs) TagsFilterNotDimensionPtrInput {
	return (*tagsFilterNotDimensionPtrType)(v)
}

func (*tagsFilterNotDimensionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterNotDimension)(nil)).Elem()
}

func (i *tagsFilterNotDimensionPtrType) ToTagsFilterNotDimensionPtrOutput() TagsFilterNotDimensionPtrOutput {
	return i.ToTagsFilterNotDimensionPtrOutputWithContext(context.Background())
}

func (i *tagsFilterNotDimensionPtrType) ToTagsFilterNotDimensionPtrOutputWithContext(ctx context.Context) TagsFilterNotDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotDimensionPtrOutput)
}

type TagsFilterNotDimensionOutput struct{ *pulumi.OutputState }

func (TagsFilterNotDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterNotDimension)(nil)).Elem()
}

func (o TagsFilterNotDimensionOutput) ToTagsFilterNotDimensionOutput() TagsFilterNotDimensionOutput {
	return o
}

func (o TagsFilterNotDimensionOutput) ToTagsFilterNotDimensionOutputWithContext(ctx context.Context) TagsFilterNotDimensionOutput {
	return o
}

func (o TagsFilterNotDimensionOutput) ToTagsFilterNotDimensionPtrOutput() TagsFilterNotDimensionPtrOutput {
	return o.ToTagsFilterNotDimensionPtrOutputWithContext(context.Background())
}

func (o TagsFilterNotDimensionOutput) ToTagsFilterNotDimensionPtrOutputWithContext(ctx context.Context) TagsFilterNotDimensionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterNotDimension) *TagsFilterNotDimension {
		return &v
	}).(TagsFilterNotDimensionPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterNotDimensionOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterNotDimension) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterNotDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterNotDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterNotDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterNotDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterNotDimensionPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterNotDimensionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterNotDimension)(nil)).Elem()
}

func (o TagsFilterNotDimensionPtrOutput) ToTagsFilterNotDimensionPtrOutput() TagsFilterNotDimensionPtrOutput {
	return o
}

func (o TagsFilterNotDimensionPtrOutput) ToTagsFilterNotDimensionPtrOutputWithContext(ctx context.Context) TagsFilterNotDimensionPtrOutput {
	return o
}

func (o TagsFilterNotDimensionPtrOutput) Elem() TagsFilterNotDimensionOutput {
	return o.ApplyT(func(v *TagsFilterNotDimension) TagsFilterNotDimension {
		if v != nil {
			return *v
		}
		var ret TagsFilterNotDimension
		return ret
	}).(TagsFilterNotDimensionOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterNotDimensionPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterNotDimension) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterNotDimensionPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterNotDimension) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterNotDimensionPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterNotDimension) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsFilterNotTags struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterNotTagsInput is an input type that accepts TagsFilterNotTagsArgs and TagsFilterNotTagsOutput values.
// You can construct a concrete instance of `TagsFilterNotTagsInput` via:
//
//          TagsFilterNotTagsArgs{...}
type TagsFilterNotTagsInput interface {
	pulumi.Input

	ToTagsFilterNotTagsOutput() TagsFilterNotTagsOutput
	ToTagsFilterNotTagsOutputWithContext(context.Context) TagsFilterNotTagsOutput
}

type TagsFilterNotTagsArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterNotTagsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterNotTags)(nil)).Elem()
}

func (i TagsFilterNotTagsArgs) ToTagsFilterNotTagsOutput() TagsFilterNotTagsOutput {
	return i.ToTagsFilterNotTagsOutputWithContext(context.Background())
}

func (i TagsFilterNotTagsArgs) ToTagsFilterNotTagsOutputWithContext(ctx context.Context) TagsFilterNotTagsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotTagsOutput)
}

func (i TagsFilterNotTagsArgs) ToTagsFilterNotTagsPtrOutput() TagsFilterNotTagsPtrOutput {
	return i.ToTagsFilterNotTagsPtrOutputWithContext(context.Background())
}

func (i TagsFilterNotTagsArgs) ToTagsFilterNotTagsPtrOutputWithContext(ctx context.Context) TagsFilterNotTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotTagsOutput).ToTagsFilterNotTagsPtrOutputWithContext(ctx)
}

// TagsFilterNotTagsPtrInput is an input type that accepts TagsFilterNotTagsArgs, TagsFilterNotTagsPtr and TagsFilterNotTagsPtrOutput values.
// You can construct a concrete instance of `TagsFilterNotTagsPtrInput` via:
//
//          TagsFilterNotTagsArgs{...}
//
//  or:
//
//          nil
type TagsFilterNotTagsPtrInput interface {
	pulumi.Input

	ToTagsFilterNotTagsPtrOutput() TagsFilterNotTagsPtrOutput
	ToTagsFilterNotTagsPtrOutputWithContext(context.Context) TagsFilterNotTagsPtrOutput
}

type tagsFilterNotTagsPtrType TagsFilterNotTagsArgs

func TagsFilterNotTagsPtr(v *TagsFilterNotTagsArgs) TagsFilterNotTagsPtrInput {
	return (*tagsFilterNotTagsPtrType)(v)
}

func (*tagsFilterNotTagsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterNotTags)(nil)).Elem()
}

func (i *tagsFilterNotTagsPtrType) ToTagsFilterNotTagsPtrOutput() TagsFilterNotTagsPtrOutput {
	return i.ToTagsFilterNotTagsPtrOutputWithContext(context.Background())
}

func (i *tagsFilterNotTagsPtrType) ToTagsFilterNotTagsPtrOutputWithContext(ctx context.Context) TagsFilterNotTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterNotTagsPtrOutput)
}

type TagsFilterNotTagsOutput struct{ *pulumi.OutputState }

func (TagsFilterNotTagsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterNotTags)(nil)).Elem()
}

func (o TagsFilterNotTagsOutput) ToTagsFilterNotTagsOutput() TagsFilterNotTagsOutput {
	return o
}

func (o TagsFilterNotTagsOutput) ToTagsFilterNotTagsOutputWithContext(ctx context.Context) TagsFilterNotTagsOutput {
	return o
}

func (o TagsFilterNotTagsOutput) ToTagsFilterNotTagsPtrOutput() TagsFilterNotTagsPtrOutput {
	return o.ToTagsFilterNotTagsPtrOutputWithContext(context.Background())
}

func (o TagsFilterNotTagsOutput) ToTagsFilterNotTagsPtrOutputWithContext(ctx context.Context) TagsFilterNotTagsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterNotTags) *TagsFilterNotTags {
		return &v
	}).(TagsFilterNotTagsPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterNotTagsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterNotTags) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterNotTagsOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterNotTags) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterNotTagsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterNotTags) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterNotTagsPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterNotTagsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterNotTags)(nil)).Elem()
}

func (o TagsFilterNotTagsPtrOutput) ToTagsFilterNotTagsPtrOutput() TagsFilterNotTagsPtrOutput {
	return o
}

func (o TagsFilterNotTagsPtrOutput) ToTagsFilterNotTagsPtrOutputWithContext(ctx context.Context) TagsFilterNotTagsPtrOutput {
	return o
}

func (o TagsFilterNotTagsPtrOutput) Elem() TagsFilterNotTagsOutput {
	return o.ApplyT(func(v *TagsFilterNotTags) TagsFilterNotTags {
		if v != nil {
			return *v
		}
		var ret TagsFilterNotTags
		return ret
	}).(TagsFilterNotTagsOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterNotTagsPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterNotTags) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterNotTagsPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterNotTags) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterNotTagsPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterNotTags) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsFilterOr struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory *TagsFilterOrCostCategory `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension *TagsFilterOrDimension `pulumi:"dimension"`
	// Tags that match your request.
	Tags *TagsFilterOrTags `pulumi:"tags"`
}

// TagsFilterOrInput is an input type that accepts TagsFilterOrArgs and TagsFilterOrOutput values.
// You can construct a concrete instance of `TagsFilterOrInput` via:
//
//          TagsFilterOrArgs{...}
type TagsFilterOrInput interface {
	pulumi.Input

	ToTagsFilterOrOutput() TagsFilterOrOutput
	ToTagsFilterOrOutputWithContext(context.Context) TagsFilterOrOutput
}

type TagsFilterOrArgs struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategory TagsFilterOrCostCategoryPtrInput `pulumi:"costCategory"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimension TagsFilterOrDimensionPtrInput `pulumi:"dimension"`
	// Tags that match your request.
	Tags TagsFilterOrTagsPtrInput `pulumi:"tags"`
}

func (TagsFilterOrArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterOr)(nil)).Elem()
}

func (i TagsFilterOrArgs) ToTagsFilterOrOutput() TagsFilterOrOutput {
	return i.ToTagsFilterOrOutputWithContext(context.Background())
}

func (i TagsFilterOrArgs) ToTagsFilterOrOutputWithContext(ctx context.Context) TagsFilterOrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOrOutput)
}

// TagsFilterOrArrayInput is an input type that accepts TagsFilterOrArray and TagsFilterOrArrayOutput values.
// You can construct a concrete instance of `TagsFilterOrArrayInput` via:
//
//          TagsFilterOrArray{ TagsFilterOrArgs{...} }
type TagsFilterOrArrayInput interface {
	pulumi.Input

	ToTagsFilterOrArrayOutput() TagsFilterOrArrayOutput
	ToTagsFilterOrArrayOutputWithContext(context.Context) TagsFilterOrArrayOutput
}

type TagsFilterOrArray []TagsFilterOrInput

func (TagsFilterOrArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TagsFilterOr)(nil)).Elem()
}

func (i TagsFilterOrArray) ToTagsFilterOrArrayOutput() TagsFilterOrArrayOutput {
	return i.ToTagsFilterOrArrayOutputWithContext(context.Background())
}

func (i TagsFilterOrArray) ToTagsFilterOrArrayOutputWithContext(ctx context.Context) TagsFilterOrArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOrArrayOutput)
}

type TagsFilterOrOutput struct{ *pulumi.OutputState }

func (TagsFilterOrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterOr)(nil)).Elem()
}

func (o TagsFilterOrOutput) ToTagsFilterOrOutput() TagsFilterOrOutput {
	return o
}

func (o TagsFilterOrOutput) ToTagsFilterOrOutputWithContext(ctx context.Context) TagsFilterOrOutput {
	return o
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o TagsFilterOrOutput) CostCategory() TagsFilterOrCostCategoryPtrOutput {
	return o.ApplyT(func(v TagsFilterOr) *TagsFilterOrCostCategory { return v.CostCategory }).(TagsFilterOrCostCategoryPtrOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o TagsFilterOrOutput) Dimension() TagsFilterOrDimensionPtrOutput {
	return o.ApplyT(func(v TagsFilterOr) *TagsFilterOrDimension { return v.Dimension }).(TagsFilterOrDimensionPtrOutput)
}

// Tags that match your request.
func (o TagsFilterOrOutput) Tags() TagsFilterOrTagsPtrOutput {
	return o.ApplyT(func(v TagsFilterOr) *TagsFilterOrTags { return v.Tags }).(TagsFilterOrTagsPtrOutput)
}

type TagsFilterOrArrayOutput struct{ *pulumi.OutputState }

func (TagsFilterOrArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TagsFilterOr)(nil)).Elem()
}

func (o TagsFilterOrArrayOutput) ToTagsFilterOrArrayOutput() TagsFilterOrArrayOutput {
	return o
}

func (o TagsFilterOrArrayOutput) ToTagsFilterOrArrayOutputWithContext(ctx context.Context) TagsFilterOrArrayOutput {
	return o
}

func (o TagsFilterOrArrayOutput) Index(i pulumi.IntInput) TagsFilterOrOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TagsFilterOr {
		return vs[0].([]TagsFilterOr)[vs[1].(int)]
	}).(TagsFilterOrOutput)
}

type TagsFilterOrCostCategory struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterOrCostCategoryInput is an input type that accepts TagsFilterOrCostCategoryArgs and TagsFilterOrCostCategoryOutput values.
// You can construct a concrete instance of `TagsFilterOrCostCategoryInput` via:
//
//          TagsFilterOrCostCategoryArgs{...}
type TagsFilterOrCostCategoryInput interface {
	pulumi.Input

	ToTagsFilterOrCostCategoryOutput() TagsFilterOrCostCategoryOutput
	ToTagsFilterOrCostCategoryOutputWithContext(context.Context) TagsFilterOrCostCategoryOutput
}

type TagsFilterOrCostCategoryArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterOrCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterOrCostCategory)(nil)).Elem()
}

func (i TagsFilterOrCostCategoryArgs) ToTagsFilterOrCostCategoryOutput() TagsFilterOrCostCategoryOutput {
	return i.ToTagsFilterOrCostCategoryOutputWithContext(context.Background())
}

func (i TagsFilterOrCostCategoryArgs) ToTagsFilterOrCostCategoryOutputWithContext(ctx context.Context) TagsFilterOrCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOrCostCategoryOutput)
}

func (i TagsFilterOrCostCategoryArgs) ToTagsFilterOrCostCategoryPtrOutput() TagsFilterOrCostCategoryPtrOutput {
	return i.ToTagsFilterOrCostCategoryPtrOutputWithContext(context.Background())
}

func (i TagsFilterOrCostCategoryArgs) ToTagsFilterOrCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterOrCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOrCostCategoryOutput).ToTagsFilterOrCostCategoryPtrOutputWithContext(ctx)
}

// TagsFilterOrCostCategoryPtrInput is an input type that accepts TagsFilterOrCostCategoryArgs, TagsFilterOrCostCategoryPtr and TagsFilterOrCostCategoryPtrOutput values.
// You can construct a concrete instance of `TagsFilterOrCostCategoryPtrInput` via:
//
//          TagsFilterOrCostCategoryArgs{...}
//
//  or:
//
//          nil
type TagsFilterOrCostCategoryPtrInput interface {
	pulumi.Input

	ToTagsFilterOrCostCategoryPtrOutput() TagsFilterOrCostCategoryPtrOutput
	ToTagsFilterOrCostCategoryPtrOutputWithContext(context.Context) TagsFilterOrCostCategoryPtrOutput
}

type tagsFilterOrCostCategoryPtrType TagsFilterOrCostCategoryArgs

func TagsFilterOrCostCategoryPtr(v *TagsFilterOrCostCategoryArgs) TagsFilterOrCostCategoryPtrInput {
	return (*tagsFilterOrCostCategoryPtrType)(v)
}

func (*tagsFilterOrCostCategoryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterOrCostCategory)(nil)).Elem()
}

func (i *tagsFilterOrCostCategoryPtrType) ToTagsFilterOrCostCategoryPtrOutput() TagsFilterOrCostCategoryPtrOutput {
	return i.ToTagsFilterOrCostCategoryPtrOutputWithContext(context.Background())
}

func (i *tagsFilterOrCostCategoryPtrType) ToTagsFilterOrCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterOrCostCategoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOrCostCategoryPtrOutput)
}

type TagsFilterOrCostCategoryOutput struct{ *pulumi.OutputState }

func (TagsFilterOrCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterOrCostCategory)(nil)).Elem()
}

func (o TagsFilterOrCostCategoryOutput) ToTagsFilterOrCostCategoryOutput() TagsFilterOrCostCategoryOutput {
	return o
}

func (o TagsFilterOrCostCategoryOutput) ToTagsFilterOrCostCategoryOutputWithContext(ctx context.Context) TagsFilterOrCostCategoryOutput {
	return o
}

func (o TagsFilterOrCostCategoryOutput) ToTagsFilterOrCostCategoryPtrOutput() TagsFilterOrCostCategoryPtrOutput {
	return o.ToTagsFilterOrCostCategoryPtrOutputWithContext(context.Background())
}

func (o TagsFilterOrCostCategoryOutput) ToTagsFilterOrCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterOrCostCategoryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterOrCostCategory) *TagsFilterOrCostCategory {
		return &v
	}).(TagsFilterOrCostCategoryPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterOrCostCategoryOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterOrCostCategory) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterOrCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterOrCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterOrCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterOrCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterOrCostCategoryPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterOrCostCategoryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterOrCostCategory)(nil)).Elem()
}

func (o TagsFilterOrCostCategoryPtrOutput) ToTagsFilterOrCostCategoryPtrOutput() TagsFilterOrCostCategoryPtrOutput {
	return o
}

func (o TagsFilterOrCostCategoryPtrOutput) ToTagsFilterOrCostCategoryPtrOutputWithContext(ctx context.Context) TagsFilterOrCostCategoryPtrOutput {
	return o
}

func (o TagsFilterOrCostCategoryPtrOutput) Elem() TagsFilterOrCostCategoryOutput {
	return o.ApplyT(func(v *TagsFilterOrCostCategory) TagsFilterOrCostCategory {
		if v != nil {
			return *v
		}
		var ret TagsFilterOrCostCategory
		return ret
	}).(TagsFilterOrCostCategoryOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterOrCostCategoryPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterOrCostCategory) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterOrCostCategoryPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterOrCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterOrCostCategoryPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterOrCostCategory) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsFilterOrDimension struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterOrDimensionInput is an input type that accepts TagsFilterOrDimensionArgs and TagsFilterOrDimensionOutput values.
// You can construct a concrete instance of `TagsFilterOrDimensionInput` via:
//
//          TagsFilterOrDimensionArgs{...}
type TagsFilterOrDimensionInput interface {
	pulumi.Input

	ToTagsFilterOrDimensionOutput() TagsFilterOrDimensionOutput
	ToTagsFilterOrDimensionOutputWithContext(context.Context) TagsFilterOrDimensionOutput
}

type TagsFilterOrDimensionArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterOrDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterOrDimension)(nil)).Elem()
}

func (i TagsFilterOrDimensionArgs) ToTagsFilterOrDimensionOutput() TagsFilterOrDimensionOutput {
	return i.ToTagsFilterOrDimensionOutputWithContext(context.Background())
}

func (i TagsFilterOrDimensionArgs) ToTagsFilterOrDimensionOutputWithContext(ctx context.Context) TagsFilterOrDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOrDimensionOutput)
}

func (i TagsFilterOrDimensionArgs) ToTagsFilterOrDimensionPtrOutput() TagsFilterOrDimensionPtrOutput {
	return i.ToTagsFilterOrDimensionPtrOutputWithContext(context.Background())
}

func (i TagsFilterOrDimensionArgs) ToTagsFilterOrDimensionPtrOutputWithContext(ctx context.Context) TagsFilterOrDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOrDimensionOutput).ToTagsFilterOrDimensionPtrOutputWithContext(ctx)
}

// TagsFilterOrDimensionPtrInput is an input type that accepts TagsFilterOrDimensionArgs, TagsFilterOrDimensionPtr and TagsFilterOrDimensionPtrOutput values.
// You can construct a concrete instance of `TagsFilterOrDimensionPtrInput` via:
//
//          TagsFilterOrDimensionArgs{...}
//
//  or:
//
//          nil
type TagsFilterOrDimensionPtrInput interface {
	pulumi.Input

	ToTagsFilterOrDimensionPtrOutput() TagsFilterOrDimensionPtrOutput
	ToTagsFilterOrDimensionPtrOutputWithContext(context.Context) TagsFilterOrDimensionPtrOutput
}

type tagsFilterOrDimensionPtrType TagsFilterOrDimensionArgs

func TagsFilterOrDimensionPtr(v *TagsFilterOrDimensionArgs) TagsFilterOrDimensionPtrInput {
	return (*tagsFilterOrDimensionPtrType)(v)
}

func (*tagsFilterOrDimensionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterOrDimension)(nil)).Elem()
}

func (i *tagsFilterOrDimensionPtrType) ToTagsFilterOrDimensionPtrOutput() TagsFilterOrDimensionPtrOutput {
	return i.ToTagsFilterOrDimensionPtrOutputWithContext(context.Background())
}

func (i *tagsFilterOrDimensionPtrType) ToTagsFilterOrDimensionPtrOutputWithContext(ctx context.Context) TagsFilterOrDimensionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOrDimensionPtrOutput)
}

type TagsFilterOrDimensionOutput struct{ *pulumi.OutputState }

func (TagsFilterOrDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterOrDimension)(nil)).Elem()
}

func (o TagsFilterOrDimensionOutput) ToTagsFilterOrDimensionOutput() TagsFilterOrDimensionOutput {
	return o
}

func (o TagsFilterOrDimensionOutput) ToTagsFilterOrDimensionOutputWithContext(ctx context.Context) TagsFilterOrDimensionOutput {
	return o
}

func (o TagsFilterOrDimensionOutput) ToTagsFilterOrDimensionPtrOutput() TagsFilterOrDimensionPtrOutput {
	return o.ToTagsFilterOrDimensionPtrOutputWithContext(context.Background())
}

func (o TagsFilterOrDimensionOutput) ToTagsFilterOrDimensionPtrOutputWithContext(ctx context.Context) TagsFilterOrDimensionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterOrDimension) *TagsFilterOrDimension {
		return &v
	}).(TagsFilterOrDimensionPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterOrDimensionOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterOrDimension) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterOrDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterOrDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterOrDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterOrDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterOrDimensionPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterOrDimensionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterOrDimension)(nil)).Elem()
}

func (o TagsFilterOrDimensionPtrOutput) ToTagsFilterOrDimensionPtrOutput() TagsFilterOrDimensionPtrOutput {
	return o
}

func (o TagsFilterOrDimensionPtrOutput) ToTagsFilterOrDimensionPtrOutputWithContext(ctx context.Context) TagsFilterOrDimensionPtrOutput {
	return o
}

func (o TagsFilterOrDimensionPtrOutput) Elem() TagsFilterOrDimensionOutput {
	return o.ApplyT(func(v *TagsFilterOrDimension) TagsFilterOrDimension {
		if v != nil {
			return *v
		}
		var ret TagsFilterOrDimension
		return ret
	}).(TagsFilterOrDimensionOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterOrDimensionPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterOrDimension) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterOrDimensionPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterOrDimension) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterOrDimensionPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterOrDimension) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsFilterOrTags struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterOrTagsInput is an input type that accepts TagsFilterOrTagsArgs and TagsFilterOrTagsOutput values.
// You can construct a concrete instance of `TagsFilterOrTagsInput` via:
//
//          TagsFilterOrTagsArgs{...}
type TagsFilterOrTagsInput interface {
	pulumi.Input

	ToTagsFilterOrTagsOutput() TagsFilterOrTagsOutput
	ToTagsFilterOrTagsOutputWithContext(context.Context) TagsFilterOrTagsOutput
}

type TagsFilterOrTagsArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterOrTagsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterOrTags)(nil)).Elem()
}

func (i TagsFilterOrTagsArgs) ToTagsFilterOrTagsOutput() TagsFilterOrTagsOutput {
	return i.ToTagsFilterOrTagsOutputWithContext(context.Background())
}

func (i TagsFilterOrTagsArgs) ToTagsFilterOrTagsOutputWithContext(ctx context.Context) TagsFilterOrTagsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOrTagsOutput)
}

func (i TagsFilterOrTagsArgs) ToTagsFilterOrTagsPtrOutput() TagsFilterOrTagsPtrOutput {
	return i.ToTagsFilterOrTagsPtrOutputWithContext(context.Background())
}

func (i TagsFilterOrTagsArgs) ToTagsFilterOrTagsPtrOutputWithContext(ctx context.Context) TagsFilterOrTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOrTagsOutput).ToTagsFilterOrTagsPtrOutputWithContext(ctx)
}

// TagsFilterOrTagsPtrInput is an input type that accepts TagsFilterOrTagsArgs, TagsFilterOrTagsPtr and TagsFilterOrTagsPtrOutput values.
// You can construct a concrete instance of `TagsFilterOrTagsPtrInput` via:
//
//          TagsFilterOrTagsArgs{...}
//
//  or:
//
//          nil
type TagsFilterOrTagsPtrInput interface {
	pulumi.Input

	ToTagsFilterOrTagsPtrOutput() TagsFilterOrTagsPtrOutput
	ToTagsFilterOrTagsPtrOutputWithContext(context.Context) TagsFilterOrTagsPtrOutput
}

type tagsFilterOrTagsPtrType TagsFilterOrTagsArgs

func TagsFilterOrTagsPtr(v *TagsFilterOrTagsArgs) TagsFilterOrTagsPtrInput {
	return (*tagsFilterOrTagsPtrType)(v)
}

func (*tagsFilterOrTagsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterOrTags)(nil)).Elem()
}

func (i *tagsFilterOrTagsPtrType) ToTagsFilterOrTagsPtrOutput() TagsFilterOrTagsPtrOutput {
	return i.ToTagsFilterOrTagsPtrOutputWithContext(context.Background())
}

func (i *tagsFilterOrTagsPtrType) ToTagsFilterOrTagsPtrOutputWithContext(ctx context.Context) TagsFilterOrTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterOrTagsPtrOutput)
}

type TagsFilterOrTagsOutput struct{ *pulumi.OutputState }

func (TagsFilterOrTagsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterOrTags)(nil)).Elem()
}

func (o TagsFilterOrTagsOutput) ToTagsFilterOrTagsOutput() TagsFilterOrTagsOutput {
	return o
}

func (o TagsFilterOrTagsOutput) ToTagsFilterOrTagsOutputWithContext(ctx context.Context) TagsFilterOrTagsOutput {
	return o
}

func (o TagsFilterOrTagsOutput) ToTagsFilterOrTagsPtrOutput() TagsFilterOrTagsPtrOutput {
	return o.ToTagsFilterOrTagsPtrOutputWithContext(context.Background())
}

func (o TagsFilterOrTagsOutput) ToTagsFilterOrTagsPtrOutputWithContext(ctx context.Context) TagsFilterOrTagsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterOrTags) *TagsFilterOrTags {
		return &v
	}).(TagsFilterOrTagsPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterOrTagsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterOrTags) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterOrTagsOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterOrTags) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterOrTagsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterOrTags) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterOrTagsPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterOrTagsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterOrTags)(nil)).Elem()
}

func (o TagsFilterOrTagsPtrOutput) ToTagsFilterOrTagsPtrOutput() TagsFilterOrTagsPtrOutput {
	return o
}

func (o TagsFilterOrTagsPtrOutput) ToTagsFilterOrTagsPtrOutputWithContext(ctx context.Context) TagsFilterOrTagsPtrOutput {
	return o
}

func (o TagsFilterOrTagsPtrOutput) Elem() TagsFilterOrTagsOutput {
	return o.ApplyT(func(v *TagsFilterOrTags) TagsFilterOrTags {
		if v != nil {
			return *v
		}
		var ret TagsFilterOrTags
		return ret
	}).(TagsFilterOrTagsOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterOrTagsPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterOrTags) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterOrTagsPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterOrTags) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterOrTagsPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterOrTags) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsFilterTags struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values []string `pulumi:"values"`
}

// TagsFilterTagsInput is an input type that accepts TagsFilterTagsArgs and TagsFilterTagsOutput values.
// You can construct a concrete instance of `TagsFilterTagsInput` via:
//
//          TagsFilterTagsArgs{...}
type TagsFilterTagsInput interface {
	pulumi.Input

	ToTagsFilterTagsOutput() TagsFilterTagsOutput
	ToTagsFilterTagsOutputWithContext(context.Context) TagsFilterTagsOutput
}

type TagsFilterTagsArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Specific value of the Cost Category.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (TagsFilterTagsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterTags)(nil)).Elem()
}

func (i TagsFilterTagsArgs) ToTagsFilterTagsOutput() TagsFilterTagsOutput {
	return i.ToTagsFilterTagsOutputWithContext(context.Background())
}

func (i TagsFilterTagsArgs) ToTagsFilterTagsOutputWithContext(ctx context.Context) TagsFilterTagsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterTagsOutput)
}

func (i TagsFilterTagsArgs) ToTagsFilterTagsPtrOutput() TagsFilterTagsPtrOutput {
	return i.ToTagsFilterTagsPtrOutputWithContext(context.Background())
}

func (i TagsFilterTagsArgs) ToTagsFilterTagsPtrOutputWithContext(ctx context.Context) TagsFilterTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterTagsOutput).ToTagsFilterTagsPtrOutputWithContext(ctx)
}

// TagsFilterTagsPtrInput is an input type that accepts TagsFilterTagsArgs, TagsFilterTagsPtr and TagsFilterTagsPtrOutput values.
// You can construct a concrete instance of `TagsFilterTagsPtrInput` via:
//
//          TagsFilterTagsArgs{...}
//
//  or:
//
//          nil
type TagsFilterTagsPtrInput interface {
	pulumi.Input

	ToTagsFilterTagsPtrOutput() TagsFilterTagsPtrOutput
	ToTagsFilterTagsPtrOutputWithContext(context.Context) TagsFilterTagsPtrOutput
}

type tagsFilterTagsPtrType TagsFilterTagsArgs

func TagsFilterTagsPtr(v *TagsFilterTagsArgs) TagsFilterTagsPtrInput {
	return (*tagsFilterTagsPtrType)(v)
}

func (*tagsFilterTagsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterTags)(nil)).Elem()
}

func (i *tagsFilterTagsPtrType) ToTagsFilterTagsPtrOutput() TagsFilterTagsPtrOutput {
	return i.ToTagsFilterTagsPtrOutputWithContext(context.Background())
}

func (i *tagsFilterTagsPtrType) ToTagsFilterTagsPtrOutputWithContext(ctx context.Context) TagsFilterTagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsFilterTagsPtrOutput)
}

type TagsFilterTagsOutput struct{ *pulumi.OutputState }

func (TagsFilterTagsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsFilterTags)(nil)).Elem()
}

func (o TagsFilterTagsOutput) ToTagsFilterTagsOutput() TagsFilterTagsOutput {
	return o
}

func (o TagsFilterTagsOutput) ToTagsFilterTagsOutputWithContext(ctx context.Context) TagsFilterTagsOutput {
	return o
}

func (o TagsFilterTagsOutput) ToTagsFilterTagsPtrOutput() TagsFilterTagsPtrOutput {
	return o.ToTagsFilterTagsPtrOutputWithContext(context.Background())
}

func (o TagsFilterTagsOutput) ToTagsFilterTagsPtrOutputWithContext(ctx context.Context) TagsFilterTagsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagsFilterTags) *TagsFilterTags {
		return &v
	}).(TagsFilterTagsPtrOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterTagsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsFilterTags) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterTagsOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterTags) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterTagsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsFilterTags) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type TagsFilterTagsPtrOutput struct{ *pulumi.OutputState }

func (TagsFilterTagsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagsFilterTags)(nil)).Elem()
}

func (o TagsFilterTagsPtrOutput) ToTagsFilterTagsPtrOutput() TagsFilterTagsPtrOutput {
	return o
}

func (o TagsFilterTagsPtrOutput) ToTagsFilterTagsPtrOutputWithContext(ctx context.Context) TagsFilterTagsPtrOutput {
	return o
}

func (o TagsFilterTagsPtrOutput) Elem() TagsFilterTagsOutput {
	return o.ApplyT(func(v *TagsFilterTags) TagsFilterTags {
		if v != nil {
			return *v
		}
		var ret TagsFilterTags
		return ret
	}).(TagsFilterTagsOutput)
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsFilterTagsPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TagsFilterTags) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o TagsFilterTagsPtrOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterTags) []string {
		if v == nil {
			return nil
		}
		return v.MatchOptions
	}).(pulumi.StringArrayOutput)
}

// Specific value of the Cost Category.
func (o TagsFilterTagsPtrOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagsFilterTags) []string {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type TagsSortBy struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key *string `pulumi:"key"`
	// order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
	SortOrder *string `pulumi:"sortOrder"`
}

// TagsSortByInput is an input type that accepts TagsSortByArgs and TagsSortByOutput values.
// You can construct a concrete instance of `TagsSortByInput` via:
//
//          TagsSortByArgs{...}
type TagsSortByInput interface {
	pulumi.Input

	ToTagsSortByOutput() TagsSortByOutput
	ToTagsSortByOutputWithContext(context.Context) TagsSortByOutput
}

type TagsSortByArgs struct {
	// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
	SortOrder pulumi.StringPtrInput `pulumi:"sortOrder"`
}

func (TagsSortByArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsSortBy)(nil)).Elem()
}

func (i TagsSortByArgs) ToTagsSortByOutput() TagsSortByOutput {
	return i.ToTagsSortByOutputWithContext(context.Background())
}

func (i TagsSortByArgs) ToTagsSortByOutputWithContext(ctx context.Context) TagsSortByOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsSortByOutput)
}

// TagsSortByArrayInput is an input type that accepts TagsSortByArray and TagsSortByArrayOutput values.
// You can construct a concrete instance of `TagsSortByArrayInput` via:
//
//          TagsSortByArray{ TagsSortByArgs{...} }
type TagsSortByArrayInput interface {
	pulumi.Input

	ToTagsSortByArrayOutput() TagsSortByArrayOutput
	ToTagsSortByArrayOutputWithContext(context.Context) TagsSortByArrayOutput
}

type TagsSortByArray []TagsSortByInput

func (TagsSortByArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TagsSortBy)(nil)).Elem()
}

func (i TagsSortByArray) ToTagsSortByArrayOutput() TagsSortByArrayOutput {
	return i.ToTagsSortByArrayOutputWithContext(context.Background())
}

func (i TagsSortByArray) ToTagsSortByArrayOutputWithContext(ctx context.Context) TagsSortByArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsSortByArrayOutput)
}

type TagsSortByOutput struct{ *pulumi.OutputState }

func (TagsSortByOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsSortBy)(nil)).Elem()
}

func (o TagsSortByOutput) ToTagsSortByOutput() TagsSortByOutput {
	return o
}

func (o TagsSortByOutput) ToTagsSortByOutputWithContext(ctx context.Context) TagsSortByOutput {
	return o
}

// key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
func (o TagsSortByOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsSortBy) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
func (o TagsSortByOutput) SortOrder() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TagsSortBy) *string { return v.SortOrder }).(pulumi.StringPtrOutput)
}

type TagsSortByArrayOutput struct{ *pulumi.OutputState }

func (TagsSortByArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TagsSortBy)(nil)).Elem()
}

func (o TagsSortByArrayOutput) ToTagsSortByArrayOutput() TagsSortByArrayOutput {
	return o
}

func (o TagsSortByArrayOutput) ToTagsSortByArrayOutputWithContext(ctx context.Context) TagsSortByArrayOutput {
	return o
}

func (o TagsSortByArrayOutput) Index(i pulumi.IntInput) TagsSortByOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TagsSortBy {
		return vs[0].([]TagsSortBy)[vs[1].(int)]
	}).(TagsSortByOutput)
}

type TagsTimePeriod struct {
	// Beginning of the time period.
	End string `pulumi:"end"`
	// End of the time period.
	Start string `pulumi:"start"`
}

// TagsTimePeriodInput is an input type that accepts TagsTimePeriodArgs and TagsTimePeriodOutput values.
// You can construct a concrete instance of `TagsTimePeriodInput` via:
//
//          TagsTimePeriodArgs{...}
type TagsTimePeriodInput interface {
	pulumi.Input

	ToTagsTimePeriodOutput() TagsTimePeriodOutput
	ToTagsTimePeriodOutputWithContext(context.Context) TagsTimePeriodOutput
}

type TagsTimePeriodArgs struct {
	// Beginning of the time period.
	End pulumi.StringInput `pulumi:"end"`
	// End of the time period.
	Start pulumi.StringInput `pulumi:"start"`
}

func (TagsTimePeriodArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsTimePeriod)(nil)).Elem()
}

func (i TagsTimePeriodArgs) ToTagsTimePeriodOutput() TagsTimePeriodOutput {
	return i.ToTagsTimePeriodOutputWithContext(context.Background())
}

func (i TagsTimePeriodArgs) ToTagsTimePeriodOutputWithContext(ctx context.Context) TagsTimePeriodOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsTimePeriodOutput)
}

type TagsTimePeriodOutput struct{ *pulumi.OutputState }

func (TagsTimePeriodOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsTimePeriod)(nil)).Elem()
}

func (o TagsTimePeriodOutput) ToTagsTimePeriodOutput() TagsTimePeriodOutput {
	return o
}

func (o TagsTimePeriodOutput) ToTagsTimePeriodOutputWithContext(ctx context.Context) TagsTimePeriodOutput {
	return o
}

// Beginning of the time period.
func (o TagsTimePeriodOutput) End() pulumi.StringOutput {
	return o.ApplyT(func(v TagsTimePeriod) string { return v.End }).(pulumi.StringOutput)
}

// End of the time period.
func (o TagsTimePeriodOutput) Start() pulumi.StringOutput {
	return o.ApplyT(func(v TagsTimePeriod) string { return v.Start }).(pulumi.StringOutput)
}

type GetCostCategoryRule struct {
	// Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
	InheritedValues []GetCostCategoryRuleInheritedValue `pulumi:"inheritedValues"`
	// Configuration block for the `Expression` object used to categorize costs. See below.
	Rules []GetCostCategoryRuleRule `pulumi:"rules"`
	// Parameter type.
	Type string `pulumi:"type"`
	// Default value for the cost category.
	Value string `pulumi:"value"`
}

// GetCostCategoryRuleInput is an input type that accepts GetCostCategoryRuleArgs and GetCostCategoryRuleOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleInput` via:
//
//          GetCostCategoryRuleArgs{...}
type GetCostCategoryRuleInput interface {
	pulumi.Input

	ToGetCostCategoryRuleOutput() GetCostCategoryRuleOutput
	ToGetCostCategoryRuleOutputWithContext(context.Context) GetCostCategoryRuleOutput
}

type GetCostCategoryRuleArgs struct {
	// Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
	InheritedValues GetCostCategoryRuleInheritedValueArrayInput `pulumi:"inheritedValues"`
	// Configuration block for the `Expression` object used to categorize costs. See below.
	Rules GetCostCategoryRuleRuleArrayInput `pulumi:"rules"`
	// Parameter type.
	Type pulumi.StringInput `pulumi:"type"`
	// Default value for the cost category.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GetCostCategoryRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRule)(nil)).Elem()
}

func (i GetCostCategoryRuleArgs) ToGetCostCategoryRuleOutput() GetCostCategoryRuleOutput {
	return i.ToGetCostCategoryRuleOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleArgs) ToGetCostCategoryRuleOutputWithContext(ctx context.Context) GetCostCategoryRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleOutput)
}

// GetCostCategoryRuleArrayInput is an input type that accepts GetCostCategoryRuleArray and GetCostCategoryRuleArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleArrayInput` via:
//
//          GetCostCategoryRuleArray{ GetCostCategoryRuleArgs{...} }
type GetCostCategoryRuleArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleArrayOutput() GetCostCategoryRuleArrayOutput
	ToGetCostCategoryRuleArrayOutputWithContext(context.Context) GetCostCategoryRuleArrayOutput
}

type GetCostCategoryRuleArray []GetCostCategoryRuleInput

func (GetCostCategoryRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRule)(nil)).Elem()
}

func (i GetCostCategoryRuleArray) ToGetCostCategoryRuleArrayOutput() GetCostCategoryRuleArrayOutput {
	return i.ToGetCostCategoryRuleArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleArray) ToGetCostCategoryRuleArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleArrayOutput)
}

type GetCostCategoryRuleOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRule)(nil)).Elem()
}

func (o GetCostCategoryRuleOutput) ToGetCostCategoryRuleOutput() GetCostCategoryRuleOutput {
	return o
}

func (o GetCostCategoryRuleOutput) ToGetCostCategoryRuleOutputWithContext(ctx context.Context) GetCostCategoryRuleOutput {
	return o
}

// Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
func (o GetCostCategoryRuleOutput) InheritedValues() GetCostCategoryRuleInheritedValueArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRule) []GetCostCategoryRuleInheritedValue { return v.InheritedValues }).(GetCostCategoryRuleInheritedValueArrayOutput)
}

// Configuration block for the `Expression` object used to categorize costs. See below.
func (o GetCostCategoryRuleOutput) Rules() GetCostCategoryRuleRuleArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRule) []GetCostCategoryRuleRule { return v.Rules }).(GetCostCategoryRuleRuleArrayOutput)
}

// Parameter type.
func (o GetCostCategoryRuleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRule) string { return v.Type }).(pulumi.StringOutput)
}

// Default value for the cost category.
func (o GetCostCategoryRuleOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRule) string { return v.Value }).(pulumi.StringOutput)
}

type GetCostCategoryRuleArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRule)(nil)).Elem()
}

func (o GetCostCategoryRuleArrayOutput) ToGetCostCategoryRuleArrayOutput() GetCostCategoryRuleArrayOutput {
	return o
}

func (o GetCostCategoryRuleArrayOutput) ToGetCostCategoryRuleArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleArrayOutput {
	return o
}

func (o GetCostCategoryRuleArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRule {
		return vs[0].([]GetCostCategoryRule)[vs[1].(int)]
	}).(GetCostCategoryRuleOutput)
}

type GetCostCategoryRuleInheritedValue struct {
	// Key to extract cost category values.
	DimensionKey string `pulumi:"dimensionKey"`
	// Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
	DimensionName string `pulumi:"dimensionName"`
}

// GetCostCategoryRuleInheritedValueInput is an input type that accepts GetCostCategoryRuleInheritedValueArgs and GetCostCategoryRuleInheritedValueOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleInheritedValueInput` via:
//
//          GetCostCategoryRuleInheritedValueArgs{...}
type GetCostCategoryRuleInheritedValueInput interface {
	pulumi.Input

	ToGetCostCategoryRuleInheritedValueOutput() GetCostCategoryRuleInheritedValueOutput
	ToGetCostCategoryRuleInheritedValueOutputWithContext(context.Context) GetCostCategoryRuleInheritedValueOutput
}

type GetCostCategoryRuleInheritedValueArgs struct {
	// Key to extract cost category values.
	DimensionKey pulumi.StringInput `pulumi:"dimensionKey"`
	// Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
	DimensionName pulumi.StringInput `pulumi:"dimensionName"`
}

func (GetCostCategoryRuleInheritedValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleInheritedValue)(nil)).Elem()
}

func (i GetCostCategoryRuleInheritedValueArgs) ToGetCostCategoryRuleInheritedValueOutput() GetCostCategoryRuleInheritedValueOutput {
	return i.ToGetCostCategoryRuleInheritedValueOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleInheritedValueArgs) ToGetCostCategoryRuleInheritedValueOutputWithContext(ctx context.Context) GetCostCategoryRuleInheritedValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleInheritedValueOutput)
}

// GetCostCategoryRuleInheritedValueArrayInput is an input type that accepts GetCostCategoryRuleInheritedValueArray and GetCostCategoryRuleInheritedValueArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleInheritedValueArrayInput` via:
//
//          GetCostCategoryRuleInheritedValueArray{ GetCostCategoryRuleInheritedValueArgs{...} }
type GetCostCategoryRuleInheritedValueArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleInheritedValueArrayOutput() GetCostCategoryRuleInheritedValueArrayOutput
	ToGetCostCategoryRuleInheritedValueArrayOutputWithContext(context.Context) GetCostCategoryRuleInheritedValueArrayOutput
}

type GetCostCategoryRuleInheritedValueArray []GetCostCategoryRuleInheritedValueInput

func (GetCostCategoryRuleInheritedValueArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleInheritedValue)(nil)).Elem()
}

func (i GetCostCategoryRuleInheritedValueArray) ToGetCostCategoryRuleInheritedValueArrayOutput() GetCostCategoryRuleInheritedValueArrayOutput {
	return i.ToGetCostCategoryRuleInheritedValueArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleInheritedValueArray) ToGetCostCategoryRuleInheritedValueArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleInheritedValueArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleInheritedValueArrayOutput)
}

type GetCostCategoryRuleInheritedValueOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleInheritedValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleInheritedValue)(nil)).Elem()
}

func (o GetCostCategoryRuleInheritedValueOutput) ToGetCostCategoryRuleInheritedValueOutput() GetCostCategoryRuleInheritedValueOutput {
	return o
}

func (o GetCostCategoryRuleInheritedValueOutput) ToGetCostCategoryRuleInheritedValueOutputWithContext(ctx context.Context) GetCostCategoryRuleInheritedValueOutput {
	return o
}

// Key to extract cost category values.
func (o GetCostCategoryRuleInheritedValueOutput) DimensionKey() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleInheritedValue) string { return v.DimensionKey }).(pulumi.StringOutput)
}

// Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
func (o GetCostCategoryRuleInheritedValueOutput) DimensionName() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleInheritedValue) string { return v.DimensionName }).(pulumi.StringOutput)
}

type GetCostCategoryRuleInheritedValueArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleInheritedValueArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleInheritedValue)(nil)).Elem()
}

func (o GetCostCategoryRuleInheritedValueArrayOutput) ToGetCostCategoryRuleInheritedValueArrayOutput() GetCostCategoryRuleInheritedValueArrayOutput {
	return o
}

func (o GetCostCategoryRuleInheritedValueArrayOutput) ToGetCostCategoryRuleInheritedValueArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleInheritedValueArrayOutput {
	return o
}

func (o GetCostCategoryRuleInheritedValueArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleInheritedValueOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleInheritedValue {
		return vs[0].([]GetCostCategoryRuleInheritedValue)[vs[1].(int)]
	}).(GetCostCategoryRuleInheritedValueOutput)
}

type GetCostCategoryRuleRule struct {
	// Return results that match both `Dimension` objects.
	Ands []GetCostCategoryRuleRuleAnd `pulumi:"ands"`
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategories []GetCostCategoryRuleRuleCostCategory `pulumi:"costCategories"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimensions []GetCostCategoryRuleRuleDimension `pulumi:"dimensions"`
	// Return results that match both `Dimension` object.
	Nots []GetCostCategoryRuleRuleNot `pulumi:"nots"`
	// Return results that match both `Dimension` object.
	Ors  []GetCostCategoryRuleRuleOr  `pulumi:"ors"`
	Tags []GetCostCategoryRuleRuleTag `pulumi:"tags"`
}

// GetCostCategoryRuleRuleInput is an input type that accepts GetCostCategoryRuleRuleArgs and GetCostCategoryRuleRuleOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleInput` via:
//
//          GetCostCategoryRuleRuleArgs{...}
type GetCostCategoryRuleRuleInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleOutput() GetCostCategoryRuleRuleOutput
	ToGetCostCategoryRuleRuleOutputWithContext(context.Context) GetCostCategoryRuleRuleOutput
}

type GetCostCategoryRuleRuleArgs struct {
	// Return results that match both `Dimension` objects.
	Ands GetCostCategoryRuleRuleAndArrayInput `pulumi:"ands"`
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategories GetCostCategoryRuleRuleCostCategoryArrayInput `pulumi:"costCategories"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimensions GetCostCategoryRuleRuleDimensionArrayInput `pulumi:"dimensions"`
	// Return results that match both `Dimension` object.
	Nots GetCostCategoryRuleRuleNotArrayInput `pulumi:"nots"`
	// Return results that match both `Dimension` object.
	Ors  GetCostCategoryRuleRuleOrArrayInput  `pulumi:"ors"`
	Tags GetCostCategoryRuleRuleTagArrayInput `pulumi:"tags"`
}

func (GetCostCategoryRuleRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRule)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleArgs) ToGetCostCategoryRuleRuleOutput() GetCostCategoryRuleRuleOutput {
	return i.ToGetCostCategoryRuleRuleOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleArgs) ToGetCostCategoryRuleRuleOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleOutput)
}

// GetCostCategoryRuleRuleArrayInput is an input type that accepts GetCostCategoryRuleRuleArray and GetCostCategoryRuleRuleArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleArrayInput` via:
//
//          GetCostCategoryRuleRuleArray{ GetCostCategoryRuleRuleArgs{...} }
type GetCostCategoryRuleRuleArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleArrayOutput() GetCostCategoryRuleRuleArrayOutput
	ToGetCostCategoryRuleRuleArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleArrayOutput
}

type GetCostCategoryRuleRuleArray []GetCostCategoryRuleRuleInput

func (GetCostCategoryRuleRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRule)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleArray) ToGetCostCategoryRuleRuleArrayOutput() GetCostCategoryRuleRuleArrayOutput {
	return i.ToGetCostCategoryRuleRuleArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleArray) ToGetCostCategoryRuleRuleArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleArrayOutput)
}

type GetCostCategoryRuleRuleOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRule)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleOutput) ToGetCostCategoryRuleRuleOutput() GetCostCategoryRuleRuleOutput {
	return o
}

func (o GetCostCategoryRuleRuleOutput) ToGetCostCategoryRuleRuleOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOutput {
	return o
}

// Return results that match both `Dimension` objects.
func (o GetCostCategoryRuleRuleOutput) Ands() GetCostCategoryRuleRuleAndArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRule) []GetCostCategoryRuleRuleAnd { return v.Ands }).(GetCostCategoryRuleRuleAndArrayOutput)
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o GetCostCategoryRuleRuleOutput) CostCategories() GetCostCategoryRuleRuleCostCategoryArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRule) []GetCostCategoryRuleRuleCostCategory { return v.CostCategories }).(GetCostCategoryRuleRuleCostCategoryArrayOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o GetCostCategoryRuleRuleOutput) Dimensions() GetCostCategoryRuleRuleDimensionArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRule) []GetCostCategoryRuleRuleDimension { return v.Dimensions }).(GetCostCategoryRuleRuleDimensionArrayOutput)
}

// Return results that match both `Dimension` object.
func (o GetCostCategoryRuleRuleOutput) Nots() GetCostCategoryRuleRuleNotArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRule) []GetCostCategoryRuleRuleNot { return v.Nots }).(GetCostCategoryRuleRuleNotArrayOutput)
}

// Return results that match both `Dimension` object.
func (o GetCostCategoryRuleRuleOutput) Ors() GetCostCategoryRuleRuleOrArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRule) []GetCostCategoryRuleRuleOr { return v.Ors }).(GetCostCategoryRuleRuleOrArrayOutput)
}

func (o GetCostCategoryRuleRuleOutput) Tags() GetCostCategoryRuleRuleTagArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRule) []GetCostCategoryRuleRuleTag { return v.Tags }).(GetCostCategoryRuleRuleTagArrayOutput)
}

type GetCostCategoryRuleRuleArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRule)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleArrayOutput) ToGetCostCategoryRuleRuleArrayOutput() GetCostCategoryRuleRuleArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleArrayOutput) ToGetCostCategoryRuleRuleArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRule {
		return vs[0].([]GetCostCategoryRuleRule)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleOutput)
}

type GetCostCategoryRuleRuleAnd struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategories []GetCostCategoryRuleRuleAndCostCategory `pulumi:"costCategories"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimensions []GetCostCategoryRuleRuleAndDimension `pulumi:"dimensions"`
	Tags       []GetCostCategoryRuleRuleAndTag       `pulumi:"tags"`
}

// GetCostCategoryRuleRuleAndInput is an input type that accepts GetCostCategoryRuleRuleAndArgs and GetCostCategoryRuleRuleAndOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleAndInput` via:
//
//          GetCostCategoryRuleRuleAndArgs{...}
type GetCostCategoryRuleRuleAndInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleAndOutput() GetCostCategoryRuleRuleAndOutput
	ToGetCostCategoryRuleRuleAndOutputWithContext(context.Context) GetCostCategoryRuleRuleAndOutput
}

type GetCostCategoryRuleRuleAndArgs struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategories GetCostCategoryRuleRuleAndCostCategoryArrayInput `pulumi:"costCategories"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimensions GetCostCategoryRuleRuleAndDimensionArrayInput `pulumi:"dimensions"`
	Tags       GetCostCategoryRuleRuleAndTagArrayInput       `pulumi:"tags"`
}

func (GetCostCategoryRuleRuleAndArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleAnd)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleAndArgs) ToGetCostCategoryRuleRuleAndOutput() GetCostCategoryRuleRuleAndOutput {
	return i.ToGetCostCategoryRuleRuleAndOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleAndArgs) ToGetCostCategoryRuleRuleAndOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleAndOutput)
}

// GetCostCategoryRuleRuleAndArrayInput is an input type that accepts GetCostCategoryRuleRuleAndArray and GetCostCategoryRuleRuleAndArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleAndArrayInput` via:
//
//          GetCostCategoryRuleRuleAndArray{ GetCostCategoryRuleRuleAndArgs{...} }
type GetCostCategoryRuleRuleAndArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleAndArrayOutput() GetCostCategoryRuleRuleAndArrayOutput
	ToGetCostCategoryRuleRuleAndArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleAndArrayOutput
}

type GetCostCategoryRuleRuleAndArray []GetCostCategoryRuleRuleAndInput

func (GetCostCategoryRuleRuleAndArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleAnd)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleAndArray) ToGetCostCategoryRuleRuleAndArrayOutput() GetCostCategoryRuleRuleAndArrayOutput {
	return i.ToGetCostCategoryRuleRuleAndArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleAndArray) ToGetCostCategoryRuleRuleAndArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleAndArrayOutput)
}

type GetCostCategoryRuleRuleAndOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleAndOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleAnd)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleAndOutput) ToGetCostCategoryRuleRuleAndOutput() GetCostCategoryRuleRuleAndOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndOutput) ToGetCostCategoryRuleRuleAndOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndOutput {
	return o
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o GetCostCategoryRuleRuleAndOutput) CostCategories() GetCostCategoryRuleRuleAndCostCategoryArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAnd) []GetCostCategoryRuleRuleAndCostCategory { return v.CostCategories }).(GetCostCategoryRuleRuleAndCostCategoryArrayOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o GetCostCategoryRuleRuleAndOutput) Dimensions() GetCostCategoryRuleRuleAndDimensionArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAnd) []GetCostCategoryRuleRuleAndDimension { return v.Dimensions }).(GetCostCategoryRuleRuleAndDimensionArrayOutput)
}

func (o GetCostCategoryRuleRuleAndOutput) Tags() GetCostCategoryRuleRuleAndTagArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAnd) []GetCostCategoryRuleRuleAndTag { return v.Tags }).(GetCostCategoryRuleRuleAndTagArrayOutput)
}

type GetCostCategoryRuleRuleAndArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleAndArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleAnd)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleAndArrayOutput) ToGetCostCategoryRuleRuleAndArrayOutput() GetCostCategoryRuleRuleAndArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndArrayOutput) ToGetCostCategoryRuleRuleAndArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleAndOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleAnd {
		return vs[0].([]GetCostCategoryRuleRuleAnd)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleAndOutput)
}

type GetCostCategoryRuleRuleAndCostCategory struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleAndCostCategoryInput is an input type that accepts GetCostCategoryRuleRuleAndCostCategoryArgs and GetCostCategoryRuleRuleAndCostCategoryOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleAndCostCategoryInput` via:
//
//          GetCostCategoryRuleRuleAndCostCategoryArgs{...}
type GetCostCategoryRuleRuleAndCostCategoryInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleAndCostCategoryOutput() GetCostCategoryRuleRuleAndCostCategoryOutput
	ToGetCostCategoryRuleRuleAndCostCategoryOutputWithContext(context.Context) GetCostCategoryRuleRuleAndCostCategoryOutput
}

type GetCostCategoryRuleRuleAndCostCategoryArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleAndCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleAndCostCategory)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleAndCostCategoryArgs) ToGetCostCategoryRuleRuleAndCostCategoryOutput() GetCostCategoryRuleRuleAndCostCategoryOutput {
	return i.ToGetCostCategoryRuleRuleAndCostCategoryOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleAndCostCategoryArgs) ToGetCostCategoryRuleRuleAndCostCategoryOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleAndCostCategoryOutput)
}

// GetCostCategoryRuleRuleAndCostCategoryArrayInput is an input type that accepts GetCostCategoryRuleRuleAndCostCategoryArray and GetCostCategoryRuleRuleAndCostCategoryArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleAndCostCategoryArrayInput` via:
//
//          GetCostCategoryRuleRuleAndCostCategoryArray{ GetCostCategoryRuleRuleAndCostCategoryArgs{...} }
type GetCostCategoryRuleRuleAndCostCategoryArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleAndCostCategoryArrayOutput() GetCostCategoryRuleRuleAndCostCategoryArrayOutput
	ToGetCostCategoryRuleRuleAndCostCategoryArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleAndCostCategoryArrayOutput
}

type GetCostCategoryRuleRuleAndCostCategoryArray []GetCostCategoryRuleRuleAndCostCategoryInput

func (GetCostCategoryRuleRuleAndCostCategoryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleAndCostCategory)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleAndCostCategoryArray) ToGetCostCategoryRuleRuleAndCostCategoryArrayOutput() GetCostCategoryRuleRuleAndCostCategoryArrayOutput {
	return i.ToGetCostCategoryRuleRuleAndCostCategoryArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleAndCostCategoryArray) ToGetCostCategoryRuleRuleAndCostCategoryArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndCostCategoryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleAndCostCategoryArrayOutput)
}

type GetCostCategoryRuleRuleAndCostCategoryOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleAndCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleAndCostCategory)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleAndCostCategoryOutput) ToGetCostCategoryRuleRuleAndCostCategoryOutput() GetCostCategoryRuleRuleAndCostCategoryOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndCostCategoryOutput) ToGetCostCategoryRuleRuleAndCostCategoryOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndCostCategoryOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleAndCostCategoryOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAndCostCategory) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleAndCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAndCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleAndCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAndCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleAndCostCategoryArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleAndCostCategoryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleAndCostCategory)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleAndCostCategoryArrayOutput) ToGetCostCategoryRuleRuleAndCostCategoryArrayOutput() GetCostCategoryRuleRuleAndCostCategoryArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndCostCategoryArrayOutput) ToGetCostCategoryRuleRuleAndCostCategoryArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndCostCategoryArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndCostCategoryArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleAndCostCategoryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleAndCostCategory {
		return vs[0].([]GetCostCategoryRuleRuleAndCostCategory)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleAndCostCategoryOutput)
}

type GetCostCategoryRuleRuleAndDimension struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleAndDimensionInput is an input type that accepts GetCostCategoryRuleRuleAndDimensionArgs and GetCostCategoryRuleRuleAndDimensionOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleAndDimensionInput` via:
//
//          GetCostCategoryRuleRuleAndDimensionArgs{...}
type GetCostCategoryRuleRuleAndDimensionInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleAndDimensionOutput() GetCostCategoryRuleRuleAndDimensionOutput
	ToGetCostCategoryRuleRuleAndDimensionOutputWithContext(context.Context) GetCostCategoryRuleRuleAndDimensionOutput
}

type GetCostCategoryRuleRuleAndDimensionArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleAndDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleAndDimension)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleAndDimensionArgs) ToGetCostCategoryRuleRuleAndDimensionOutput() GetCostCategoryRuleRuleAndDimensionOutput {
	return i.ToGetCostCategoryRuleRuleAndDimensionOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleAndDimensionArgs) ToGetCostCategoryRuleRuleAndDimensionOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleAndDimensionOutput)
}

// GetCostCategoryRuleRuleAndDimensionArrayInput is an input type that accepts GetCostCategoryRuleRuleAndDimensionArray and GetCostCategoryRuleRuleAndDimensionArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleAndDimensionArrayInput` via:
//
//          GetCostCategoryRuleRuleAndDimensionArray{ GetCostCategoryRuleRuleAndDimensionArgs{...} }
type GetCostCategoryRuleRuleAndDimensionArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleAndDimensionArrayOutput() GetCostCategoryRuleRuleAndDimensionArrayOutput
	ToGetCostCategoryRuleRuleAndDimensionArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleAndDimensionArrayOutput
}

type GetCostCategoryRuleRuleAndDimensionArray []GetCostCategoryRuleRuleAndDimensionInput

func (GetCostCategoryRuleRuleAndDimensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleAndDimension)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleAndDimensionArray) ToGetCostCategoryRuleRuleAndDimensionArrayOutput() GetCostCategoryRuleRuleAndDimensionArrayOutput {
	return i.ToGetCostCategoryRuleRuleAndDimensionArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleAndDimensionArray) ToGetCostCategoryRuleRuleAndDimensionArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndDimensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleAndDimensionArrayOutput)
}

type GetCostCategoryRuleRuleAndDimensionOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleAndDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleAndDimension)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleAndDimensionOutput) ToGetCostCategoryRuleRuleAndDimensionOutput() GetCostCategoryRuleRuleAndDimensionOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndDimensionOutput) ToGetCostCategoryRuleRuleAndDimensionOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndDimensionOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleAndDimensionOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAndDimension) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleAndDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAndDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleAndDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAndDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleAndDimensionArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleAndDimensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleAndDimension)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleAndDimensionArrayOutput) ToGetCostCategoryRuleRuleAndDimensionArrayOutput() GetCostCategoryRuleRuleAndDimensionArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndDimensionArrayOutput) ToGetCostCategoryRuleRuleAndDimensionArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndDimensionArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndDimensionArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleAndDimensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleAndDimension {
		return vs[0].([]GetCostCategoryRuleRuleAndDimension)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleAndDimensionOutput)
}

type GetCostCategoryRuleRuleAndTag struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleAndTagInput is an input type that accepts GetCostCategoryRuleRuleAndTagArgs and GetCostCategoryRuleRuleAndTagOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleAndTagInput` via:
//
//          GetCostCategoryRuleRuleAndTagArgs{...}
type GetCostCategoryRuleRuleAndTagInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleAndTagOutput() GetCostCategoryRuleRuleAndTagOutput
	ToGetCostCategoryRuleRuleAndTagOutputWithContext(context.Context) GetCostCategoryRuleRuleAndTagOutput
}

type GetCostCategoryRuleRuleAndTagArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleAndTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleAndTag)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleAndTagArgs) ToGetCostCategoryRuleRuleAndTagOutput() GetCostCategoryRuleRuleAndTagOutput {
	return i.ToGetCostCategoryRuleRuleAndTagOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleAndTagArgs) ToGetCostCategoryRuleRuleAndTagOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleAndTagOutput)
}

// GetCostCategoryRuleRuleAndTagArrayInput is an input type that accepts GetCostCategoryRuleRuleAndTagArray and GetCostCategoryRuleRuleAndTagArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleAndTagArrayInput` via:
//
//          GetCostCategoryRuleRuleAndTagArray{ GetCostCategoryRuleRuleAndTagArgs{...} }
type GetCostCategoryRuleRuleAndTagArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleAndTagArrayOutput() GetCostCategoryRuleRuleAndTagArrayOutput
	ToGetCostCategoryRuleRuleAndTagArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleAndTagArrayOutput
}

type GetCostCategoryRuleRuleAndTagArray []GetCostCategoryRuleRuleAndTagInput

func (GetCostCategoryRuleRuleAndTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleAndTag)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleAndTagArray) ToGetCostCategoryRuleRuleAndTagArrayOutput() GetCostCategoryRuleRuleAndTagArrayOutput {
	return i.ToGetCostCategoryRuleRuleAndTagArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleAndTagArray) ToGetCostCategoryRuleRuleAndTagArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleAndTagArrayOutput)
}

type GetCostCategoryRuleRuleAndTagOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleAndTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleAndTag)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleAndTagOutput) ToGetCostCategoryRuleRuleAndTagOutput() GetCostCategoryRuleRuleAndTagOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndTagOutput) ToGetCostCategoryRuleRuleAndTagOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndTagOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleAndTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAndTag) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleAndTagOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAndTag) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleAndTagOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleAndTag) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleAndTagArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleAndTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleAndTag)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleAndTagArrayOutput) ToGetCostCategoryRuleRuleAndTagArrayOutput() GetCostCategoryRuleRuleAndTagArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndTagArrayOutput) ToGetCostCategoryRuleRuleAndTagArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleAndTagArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleAndTagArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleAndTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleAndTag {
		return vs[0].([]GetCostCategoryRuleRuleAndTag)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleAndTagOutput)
}

type GetCostCategoryRuleRuleCostCategory struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleCostCategoryInput is an input type that accepts GetCostCategoryRuleRuleCostCategoryArgs and GetCostCategoryRuleRuleCostCategoryOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleCostCategoryInput` via:
//
//          GetCostCategoryRuleRuleCostCategoryArgs{...}
type GetCostCategoryRuleRuleCostCategoryInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleCostCategoryOutput() GetCostCategoryRuleRuleCostCategoryOutput
	ToGetCostCategoryRuleRuleCostCategoryOutputWithContext(context.Context) GetCostCategoryRuleRuleCostCategoryOutput
}

type GetCostCategoryRuleRuleCostCategoryArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleCostCategory)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleCostCategoryArgs) ToGetCostCategoryRuleRuleCostCategoryOutput() GetCostCategoryRuleRuleCostCategoryOutput {
	return i.ToGetCostCategoryRuleRuleCostCategoryOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleCostCategoryArgs) ToGetCostCategoryRuleRuleCostCategoryOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleCostCategoryOutput)
}

// GetCostCategoryRuleRuleCostCategoryArrayInput is an input type that accepts GetCostCategoryRuleRuleCostCategoryArray and GetCostCategoryRuleRuleCostCategoryArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleCostCategoryArrayInput` via:
//
//          GetCostCategoryRuleRuleCostCategoryArray{ GetCostCategoryRuleRuleCostCategoryArgs{...} }
type GetCostCategoryRuleRuleCostCategoryArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleCostCategoryArrayOutput() GetCostCategoryRuleRuleCostCategoryArrayOutput
	ToGetCostCategoryRuleRuleCostCategoryArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleCostCategoryArrayOutput
}

type GetCostCategoryRuleRuleCostCategoryArray []GetCostCategoryRuleRuleCostCategoryInput

func (GetCostCategoryRuleRuleCostCategoryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleCostCategory)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleCostCategoryArray) ToGetCostCategoryRuleRuleCostCategoryArrayOutput() GetCostCategoryRuleRuleCostCategoryArrayOutput {
	return i.ToGetCostCategoryRuleRuleCostCategoryArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleCostCategoryArray) ToGetCostCategoryRuleRuleCostCategoryArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleCostCategoryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleCostCategoryArrayOutput)
}

type GetCostCategoryRuleRuleCostCategoryOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleCostCategory)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleCostCategoryOutput) ToGetCostCategoryRuleRuleCostCategoryOutput() GetCostCategoryRuleRuleCostCategoryOutput {
	return o
}

func (o GetCostCategoryRuleRuleCostCategoryOutput) ToGetCostCategoryRuleRuleCostCategoryOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleCostCategoryOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleCostCategoryOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleCostCategory) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleCostCategoryArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleCostCategoryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleCostCategory)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleCostCategoryArrayOutput) ToGetCostCategoryRuleRuleCostCategoryArrayOutput() GetCostCategoryRuleRuleCostCategoryArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleCostCategoryArrayOutput) ToGetCostCategoryRuleRuleCostCategoryArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleCostCategoryArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleCostCategoryArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleCostCategoryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleCostCategory {
		return vs[0].([]GetCostCategoryRuleRuleCostCategory)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleCostCategoryOutput)
}

type GetCostCategoryRuleRuleDimension struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleDimensionInput is an input type that accepts GetCostCategoryRuleRuleDimensionArgs and GetCostCategoryRuleRuleDimensionOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleDimensionInput` via:
//
//          GetCostCategoryRuleRuleDimensionArgs{...}
type GetCostCategoryRuleRuleDimensionInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleDimensionOutput() GetCostCategoryRuleRuleDimensionOutput
	ToGetCostCategoryRuleRuleDimensionOutputWithContext(context.Context) GetCostCategoryRuleRuleDimensionOutput
}

type GetCostCategoryRuleRuleDimensionArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleDimension)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleDimensionArgs) ToGetCostCategoryRuleRuleDimensionOutput() GetCostCategoryRuleRuleDimensionOutput {
	return i.ToGetCostCategoryRuleRuleDimensionOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleDimensionArgs) ToGetCostCategoryRuleRuleDimensionOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleDimensionOutput)
}

// GetCostCategoryRuleRuleDimensionArrayInput is an input type that accepts GetCostCategoryRuleRuleDimensionArray and GetCostCategoryRuleRuleDimensionArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleDimensionArrayInput` via:
//
//          GetCostCategoryRuleRuleDimensionArray{ GetCostCategoryRuleRuleDimensionArgs{...} }
type GetCostCategoryRuleRuleDimensionArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleDimensionArrayOutput() GetCostCategoryRuleRuleDimensionArrayOutput
	ToGetCostCategoryRuleRuleDimensionArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleDimensionArrayOutput
}

type GetCostCategoryRuleRuleDimensionArray []GetCostCategoryRuleRuleDimensionInput

func (GetCostCategoryRuleRuleDimensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleDimension)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleDimensionArray) ToGetCostCategoryRuleRuleDimensionArrayOutput() GetCostCategoryRuleRuleDimensionArrayOutput {
	return i.ToGetCostCategoryRuleRuleDimensionArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleDimensionArray) ToGetCostCategoryRuleRuleDimensionArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleDimensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleDimensionArrayOutput)
}

type GetCostCategoryRuleRuleDimensionOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleDimension)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleDimensionOutput) ToGetCostCategoryRuleRuleDimensionOutput() GetCostCategoryRuleRuleDimensionOutput {
	return o
}

func (o GetCostCategoryRuleRuleDimensionOutput) ToGetCostCategoryRuleRuleDimensionOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleDimensionOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleDimensionOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleDimension) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleDimensionArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleDimensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleDimension)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleDimensionArrayOutput) ToGetCostCategoryRuleRuleDimensionArrayOutput() GetCostCategoryRuleRuleDimensionArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleDimensionArrayOutput) ToGetCostCategoryRuleRuleDimensionArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleDimensionArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleDimensionArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleDimensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleDimension {
		return vs[0].([]GetCostCategoryRuleRuleDimension)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleDimensionOutput)
}

type GetCostCategoryRuleRuleNot struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategories []GetCostCategoryRuleRuleNotCostCategory `pulumi:"costCategories"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimensions []GetCostCategoryRuleRuleNotDimension `pulumi:"dimensions"`
	Tags       []GetCostCategoryRuleRuleNotTag       `pulumi:"tags"`
}

// GetCostCategoryRuleRuleNotInput is an input type that accepts GetCostCategoryRuleRuleNotArgs and GetCostCategoryRuleRuleNotOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleNotInput` via:
//
//          GetCostCategoryRuleRuleNotArgs{...}
type GetCostCategoryRuleRuleNotInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleNotOutput() GetCostCategoryRuleRuleNotOutput
	ToGetCostCategoryRuleRuleNotOutputWithContext(context.Context) GetCostCategoryRuleRuleNotOutput
}

type GetCostCategoryRuleRuleNotArgs struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategories GetCostCategoryRuleRuleNotCostCategoryArrayInput `pulumi:"costCategories"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimensions GetCostCategoryRuleRuleNotDimensionArrayInput `pulumi:"dimensions"`
	Tags       GetCostCategoryRuleRuleNotTagArrayInput       `pulumi:"tags"`
}

func (GetCostCategoryRuleRuleNotArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleNot)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleNotArgs) ToGetCostCategoryRuleRuleNotOutput() GetCostCategoryRuleRuleNotOutput {
	return i.ToGetCostCategoryRuleRuleNotOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleNotArgs) ToGetCostCategoryRuleRuleNotOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleNotOutput)
}

// GetCostCategoryRuleRuleNotArrayInput is an input type that accepts GetCostCategoryRuleRuleNotArray and GetCostCategoryRuleRuleNotArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleNotArrayInput` via:
//
//          GetCostCategoryRuleRuleNotArray{ GetCostCategoryRuleRuleNotArgs{...} }
type GetCostCategoryRuleRuleNotArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleNotArrayOutput() GetCostCategoryRuleRuleNotArrayOutput
	ToGetCostCategoryRuleRuleNotArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleNotArrayOutput
}

type GetCostCategoryRuleRuleNotArray []GetCostCategoryRuleRuleNotInput

func (GetCostCategoryRuleRuleNotArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleNot)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleNotArray) ToGetCostCategoryRuleRuleNotArrayOutput() GetCostCategoryRuleRuleNotArrayOutput {
	return i.ToGetCostCategoryRuleRuleNotArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleNotArray) ToGetCostCategoryRuleRuleNotArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleNotArrayOutput)
}

type GetCostCategoryRuleRuleNotOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleNotOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleNot)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleNotOutput) ToGetCostCategoryRuleRuleNotOutput() GetCostCategoryRuleRuleNotOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotOutput) ToGetCostCategoryRuleRuleNotOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotOutput {
	return o
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o GetCostCategoryRuleRuleNotOutput) CostCategories() GetCostCategoryRuleRuleNotCostCategoryArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNot) []GetCostCategoryRuleRuleNotCostCategory { return v.CostCategories }).(GetCostCategoryRuleRuleNotCostCategoryArrayOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o GetCostCategoryRuleRuleNotOutput) Dimensions() GetCostCategoryRuleRuleNotDimensionArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNot) []GetCostCategoryRuleRuleNotDimension { return v.Dimensions }).(GetCostCategoryRuleRuleNotDimensionArrayOutput)
}

func (o GetCostCategoryRuleRuleNotOutput) Tags() GetCostCategoryRuleRuleNotTagArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNot) []GetCostCategoryRuleRuleNotTag { return v.Tags }).(GetCostCategoryRuleRuleNotTagArrayOutput)
}

type GetCostCategoryRuleRuleNotArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleNotArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleNot)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleNotArrayOutput) ToGetCostCategoryRuleRuleNotArrayOutput() GetCostCategoryRuleRuleNotArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotArrayOutput) ToGetCostCategoryRuleRuleNotArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleNotOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleNot {
		return vs[0].([]GetCostCategoryRuleRuleNot)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleNotOutput)
}

type GetCostCategoryRuleRuleNotCostCategory struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleNotCostCategoryInput is an input type that accepts GetCostCategoryRuleRuleNotCostCategoryArgs and GetCostCategoryRuleRuleNotCostCategoryOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleNotCostCategoryInput` via:
//
//          GetCostCategoryRuleRuleNotCostCategoryArgs{...}
type GetCostCategoryRuleRuleNotCostCategoryInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleNotCostCategoryOutput() GetCostCategoryRuleRuleNotCostCategoryOutput
	ToGetCostCategoryRuleRuleNotCostCategoryOutputWithContext(context.Context) GetCostCategoryRuleRuleNotCostCategoryOutput
}

type GetCostCategoryRuleRuleNotCostCategoryArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleNotCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleNotCostCategory)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleNotCostCategoryArgs) ToGetCostCategoryRuleRuleNotCostCategoryOutput() GetCostCategoryRuleRuleNotCostCategoryOutput {
	return i.ToGetCostCategoryRuleRuleNotCostCategoryOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleNotCostCategoryArgs) ToGetCostCategoryRuleRuleNotCostCategoryOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleNotCostCategoryOutput)
}

// GetCostCategoryRuleRuleNotCostCategoryArrayInput is an input type that accepts GetCostCategoryRuleRuleNotCostCategoryArray and GetCostCategoryRuleRuleNotCostCategoryArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleNotCostCategoryArrayInput` via:
//
//          GetCostCategoryRuleRuleNotCostCategoryArray{ GetCostCategoryRuleRuleNotCostCategoryArgs{...} }
type GetCostCategoryRuleRuleNotCostCategoryArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleNotCostCategoryArrayOutput() GetCostCategoryRuleRuleNotCostCategoryArrayOutput
	ToGetCostCategoryRuleRuleNotCostCategoryArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleNotCostCategoryArrayOutput
}

type GetCostCategoryRuleRuleNotCostCategoryArray []GetCostCategoryRuleRuleNotCostCategoryInput

func (GetCostCategoryRuleRuleNotCostCategoryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleNotCostCategory)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleNotCostCategoryArray) ToGetCostCategoryRuleRuleNotCostCategoryArrayOutput() GetCostCategoryRuleRuleNotCostCategoryArrayOutput {
	return i.ToGetCostCategoryRuleRuleNotCostCategoryArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleNotCostCategoryArray) ToGetCostCategoryRuleRuleNotCostCategoryArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotCostCategoryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleNotCostCategoryArrayOutput)
}

type GetCostCategoryRuleRuleNotCostCategoryOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleNotCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleNotCostCategory)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleNotCostCategoryOutput) ToGetCostCategoryRuleRuleNotCostCategoryOutput() GetCostCategoryRuleRuleNotCostCategoryOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotCostCategoryOutput) ToGetCostCategoryRuleRuleNotCostCategoryOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotCostCategoryOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleNotCostCategoryOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNotCostCategory) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleNotCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNotCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleNotCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNotCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleNotCostCategoryArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleNotCostCategoryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleNotCostCategory)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleNotCostCategoryArrayOutput) ToGetCostCategoryRuleRuleNotCostCategoryArrayOutput() GetCostCategoryRuleRuleNotCostCategoryArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotCostCategoryArrayOutput) ToGetCostCategoryRuleRuleNotCostCategoryArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotCostCategoryArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotCostCategoryArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleNotCostCategoryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleNotCostCategory {
		return vs[0].([]GetCostCategoryRuleRuleNotCostCategory)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleNotCostCategoryOutput)
}

type GetCostCategoryRuleRuleNotDimension struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleNotDimensionInput is an input type that accepts GetCostCategoryRuleRuleNotDimensionArgs and GetCostCategoryRuleRuleNotDimensionOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleNotDimensionInput` via:
//
//          GetCostCategoryRuleRuleNotDimensionArgs{...}
type GetCostCategoryRuleRuleNotDimensionInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleNotDimensionOutput() GetCostCategoryRuleRuleNotDimensionOutput
	ToGetCostCategoryRuleRuleNotDimensionOutputWithContext(context.Context) GetCostCategoryRuleRuleNotDimensionOutput
}

type GetCostCategoryRuleRuleNotDimensionArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleNotDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleNotDimension)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleNotDimensionArgs) ToGetCostCategoryRuleRuleNotDimensionOutput() GetCostCategoryRuleRuleNotDimensionOutput {
	return i.ToGetCostCategoryRuleRuleNotDimensionOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleNotDimensionArgs) ToGetCostCategoryRuleRuleNotDimensionOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleNotDimensionOutput)
}

// GetCostCategoryRuleRuleNotDimensionArrayInput is an input type that accepts GetCostCategoryRuleRuleNotDimensionArray and GetCostCategoryRuleRuleNotDimensionArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleNotDimensionArrayInput` via:
//
//          GetCostCategoryRuleRuleNotDimensionArray{ GetCostCategoryRuleRuleNotDimensionArgs{...} }
type GetCostCategoryRuleRuleNotDimensionArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleNotDimensionArrayOutput() GetCostCategoryRuleRuleNotDimensionArrayOutput
	ToGetCostCategoryRuleRuleNotDimensionArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleNotDimensionArrayOutput
}

type GetCostCategoryRuleRuleNotDimensionArray []GetCostCategoryRuleRuleNotDimensionInput

func (GetCostCategoryRuleRuleNotDimensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleNotDimension)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleNotDimensionArray) ToGetCostCategoryRuleRuleNotDimensionArrayOutput() GetCostCategoryRuleRuleNotDimensionArrayOutput {
	return i.ToGetCostCategoryRuleRuleNotDimensionArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleNotDimensionArray) ToGetCostCategoryRuleRuleNotDimensionArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotDimensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleNotDimensionArrayOutput)
}

type GetCostCategoryRuleRuleNotDimensionOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleNotDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleNotDimension)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleNotDimensionOutput) ToGetCostCategoryRuleRuleNotDimensionOutput() GetCostCategoryRuleRuleNotDimensionOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotDimensionOutput) ToGetCostCategoryRuleRuleNotDimensionOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotDimensionOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleNotDimensionOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNotDimension) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleNotDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNotDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleNotDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNotDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleNotDimensionArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleNotDimensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleNotDimension)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleNotDimensionArrayOutput) ToGetCostCategoryRuleRuleNotDimensionArrayOutput() GetCostCategoryRuleRuleNotDimensionArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotDimensionArrayOutput) ToGetCostCategoryRuleRuleNotDimensionArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotDimensionArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotDimensionArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleNotDimensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleNotDimension {
		return vs[0].([]GetCostCategoryRuleRuleNotDimension)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleNotDimensionOutput)
}

type GetCostCategoryRuleRuleNotTag struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleNotTagInput is an input type that accepts GetCostCategoryRuleRuleNotTagArgs and GetCostCategoryRuleRuleNotTagOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleNotTagInput` via:
//
//          GetCostCategoryRuleRuleNotTagArgs{...}
type GetCostCategoryRuleRuleNotTagInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleNotTagOutput() GetCostCategoryRuleRuleNotTagOutput
	ToGetCostCategoryRuleRuleNotTagOutputWithContext(context.Context) GetCostCategoryRuleRuleNotTagOutput
}

type GetCostCategoryRuleRuleNotTagArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleNotTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleNotTag)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleNotTagArgs) ToGetCostCategoryRuleRuleNotTagOutput() GetCostCategoryRuleRuleNotTagOutput {
	return i.ToGetCostCategoryRuleRuleNotTagOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleNotTagArgs) ToGetCostCategoryRuleRuleNotTagOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleNotTagOutput)
}

// GetCostCategoryRuleRuleNotTagArrayInput is an input type that accepts GetCostCategoryRuleRuleNotTagArray and GetCostCategoryRuleRuleNotTagArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleNotTagArrayInput` via:
//
//          GetCostCategoryRuleRuleNotTagArray{ GetCostCategoryRuleRuleNotTagArgs{...} }
type GetCostCategoryRuleRuleNotTagArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleNotTagArrayOutput() GetCostCategoryRuleRuleNotTagArrayOutput
	ToGetCostCategoryRuleRuleNotTagArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleNotTagArrayOutput
}

type GetCostCategoryRuleRuleNotTagArray []GetCostCategoryRuleRuleNotTagInput

func (GetCostCategoryRuleRuleNotTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleNotTag)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleNotTagArray) ToGetCostCategoryRuleRuleNotTagArrayOutput() GetCostCategoryRuleRuleNotTagArrayOutput {
	return i.ToGetCostCategoryRuleRuleNotTagArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleNotTagArray) ToGetCostCategoryRuleRuleNotTagArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleNotTagArrayOutput)
}

type GetCostCategoryRuleRuleNotTagOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleNotTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleNotTag)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleNotTagOutput) ToGetCostCategoryRuleRuleNotTagOutput() GetCostCategoryRuleRuleNotTagOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotTagOutput) ToGetCostCategoryRuleRuleNotTagOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotTagOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleNotTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNotTag) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleNotTagOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNotTag) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleNotTagOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleNotTag) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleNotTagArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleNotTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleNotTag)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleNotTagArrayOutput) ToGetCostCategoryRuleRuleNotTagArrayOutput() GetCostCategoryRuleRuleNotTagArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotTagArrayOutput) ToGetCostCategoryRuleRuleNotTagArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleNotTagArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleNotTagArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleNotTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleNotTag {
		return vs[0].([]GetCostCategoryRuleRuleNotTag)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleNotTagOutput)
}

type GetCostCategoryRuleRuleOr struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategories []GetCostCategoryRuleRuleOrCostCategory `pulumi:"costCategories"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimensions []GetCostCategoryRuleRuleOrDimension `pulumi:"dimensions"`
	Tags       []GetCostCategoryRuleRuleOrTag       `pulumi:"tags"`
}

// GetCostCategoryRuleRuleOrInput is an input type that accepts GetCostCategoryRuleRuleOrArgs and GetCostCategoryRuleRuleOrOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleOrInput` via:
//
//          GetCostCategoryRuleRuleOrArgs{...}
type GetCostCategoryRuleRuleOrInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleOrOutput() GetCostCategoryRuleRuleOrOutput
	ToGetCostCategoryRuleRuleOrOutputWithContext(context.Context) GetCostCategoryRuleRuleOrOutput
}

type GetCostCategoryRuleRuleOrArgs struct {
	// Configuration block for the filter that's based on `CostCategory` values. See below.
	CostCategories GetCostCategoryRuleRuleOrCostCategoryArrayInput `pulumi:"costCategories"`
	// Configuration block for the specific `Dimension` to use for `Expression`. See below.
	Dimensions GetCostCategoryRuleRuleOrDimensionArrayInput `pulumi:"dimensions"`
	Tags       GetCostCategoryRuleRuleOrTagArrayInput       `pulumi:"tags"`
}

func (GetCostCategoryRuleRuleOrArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleOr)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleOrArgs) ToGetCostCategoryRuleRuleOrOutput() GetCostCategoryRuleRuleOrOutput {
	return i.ToGetCostCategoryRuleRuleOrOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleOrArgs) ToGetCostCategoryRuleRuleOrOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleOrOutput)
}

// GetCostCategoryRuleRuleOrArrayInput is an input type that accepts GetCostCategoryRuleRuleOrArray and GetCostCategoryRuleRuleOrArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleOrArrayInput` via:
//
//          GetCostCategoryRuleRuleOrArray{ GetCostCategoryRuleRuleOrArgs{...} }
type GetCostCategoryRuleRuleOrArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleOrArrayOutput() GetCostCategoryRuleRuleOrArrayOutput
	ToGetCostCategoryRuleRuleOrArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleOrArrayOutput
}

type GetCostCategoryRuleRuleOrArray []GetCostCategoryRuleRuleOrInput

func (GetCostCategoryRuleRuleOrArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleOr)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleOrArray) ToGetCostCategoryRuleRuleOrArrayOutput() GetCostCategoryRuleRuleOrArrayOutput {
	return i.ToGetCostCategoryRuleRuleOrArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleOrArray) ToGetCostCategoryRuleRuleOrArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleOrArrayOutput)
}

type GetCostCategoryRuleRuleOrOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleOrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleOr)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleOrOutput) ToGetCostCategoryRuleRuleOrOutput() GetCostCategoryRuleRuleOrOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrOutput) ToGetCostCategoryRuleRuleOrOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrOutput {
	return o
}

// Configuration block for the filter that's based on `CostCategory` values. See below.
func (o GetCostCategoryRuleRuleOrOutput) CostCategories() GetCostCategoryRuleRuleOrCostCategoryArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOr) []GetCostCategoryRuleRuleOrCostCategory { return v.CostCategories }).(GetCostCategoryRuleRuleOrCostCategoryArrayOutput)
}

// Configuration block for the specific `Dimension` to use for `Expression`. See below.
func (o GetCostCategoryRuleRuleOrOutput) Dimensions() GetCostCategoryRuleRuleOrDimensionArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOr) []GetCostCategoryRuleRuleOrDimension { return v.Dimensions }).(GetCostCategoryRuleRuleOrDimensionArrayOutput)
}

func (o GetCostCategoryRuleRuleOrOutput) Tags() GetCostCategoryRuleRuleOrTagArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOr) []GetCostCategoryRuleRuleOrTag { return v.Tags }).(GetCostCategoryRuleRuleOrTagArrayOutput)
}

type GetCostCategoryRuleRuleOrArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleOrArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleOr)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleOrArrayOutput) ToGetCostCategoryRuleRuleOrArrayOutput() GetCostCategoryRuleRuleOrArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrArrayOutput) ToGetCostCategoryRuleRuleOrArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleOrOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleOr {
		return vs[0].([]GetCostCategoryRuleRuleOr)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleOrOutput)
}

type GetCostCategoryRuleRuleOrCostCategory struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleOrCostCategoryInput is an input type that accepts GetCostCategoryRuleRuleOrCostCategoryArgs and GetCostCategoryRuleRuleOrCostCategoryOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleOrCostCategoryInput` via:
//
//          GetCostCategoryRuleRuleOrCostCategoryArgs{...}
type GetCostCategoryRuleRuleOrCostCategoryInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleOrCostCategoryOutput() GetCostCategoryRuleRuleOrCostCategoryOutput
	ToGetCostCategoryRuleRuleOrCostCategoryOutputWithContext(context.Context) GetCostCategoryRuleRuleOrCostCategoryOutput
}

type GetCostCategoryRuleRuleOrCostCategoryArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleOrCostCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleOrCostCategory)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleOrCostCategoryArgs) ToGetCostCategoryRuleRuleOrCostCategoryOutput() GetCostCategoryRuleRuleOrCostCategoryOutput {
	return i.ToGetCostCategoryRuleRuleOrCostCategoryOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleOrCostCategoryArgs) ToGetCostCategoryRuleRuleOrCostCategoryOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrCostCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleOrCostCategoryOutput)
}

// GetCostCategoryRuleRuleOrCostCategoryArrayInput is an input type that accepts GetCostCategoryRuleRuleOrCostCategoryArray and GetCostCategoryRuleRuleOrCostCategoryArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleOrCostCategoryArrayInput` via:
//
//          GetCostCategoryRuleRuleOrCostCategoryArray{ GetCostCategoryRuleRuleOrCostCategoryArgs{...} }
type GetCostCategoryRuleRuleOrCostCategoryArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleOrCostCategoryArrayOutput() GetCostCategoryRuleRuleOrCostCategoryArrayOutput
	ToGetCostCategoryRuleRuleOrCostCategoryArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleOrCostCategoryArrayOutput
}

type GetCostCategoryRuleRuleOrCostCategoryArray []GetCostCategoryRuleRuleOrCostCategoryInput

func (GetCostCategoryRuleRuleOrCostCategoryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleOrCostCategory)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleOrCostCategoryArray) ToGetCostCategoryRuleRuleOrCostCategoryArrayOutput() GetCostCategoryRuleRuleOrCostCategoryArrayOutput {
	return i.ToGetCostCategoryRuleRuleOrCostCategoryArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleOrCostCategoryArray) ToGetCostCategoryRuleRuleOrCostCategoryArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrCostCategoryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleOrCostCategoryArrayOutput)
}

type GetCostCategoryRuleRuleOrCostCategoryOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleOrCostCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleOrCostCategory)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleOrCostCategoryOutput) ToGetCostCategoryRuleRuleOrCostCategoryOutput() GetCostCategoryRuleRuleOrCostCategoryOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrCostCategoryOutput) ToGetCostCategoryRuleRuleOrCostCategoryOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrCostCategoryOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleOrCostCategoryOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOrCostCategory) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleOrCostCategoryOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOrCostCategory) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleOrCostCategoryOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOrCostCategory) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleOrCostCategoryArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleOrCostCategoryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleOrCostCategory)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleOrCostCategoryArrayOutput) ToGetCostCategoryRuleRuleOrCostCategoryArrayOutput() GetCostCategoryRuleRuleOrCostCategoryArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrCostCategoryArrayOutput) ToGetCostCategoryRuleRuleOrCostCategoryArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrCostCategoryArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrCostCategoryArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleOrCostCategoryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleOrCostCategory {
		return vs[0].([]GetCostCategoryRuleRuleOrCostCategory)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleOrCostCategoryOutput)
}

type GetCostCategoryRuleRuleOrDimension struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleOrDimensionInput is an input type that accepts GetCostCategoryRuleRuleOrDimensionArgs and GetCostCategoryRuleRuleOrDimensionOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleOrDimensionInput` via:
//
//          GetCostCategoryRuleRuleOrDimensionArgs{...}
type GetCostCategoryRuleRuleOrDimensionInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleOrDimensionOutput() GetCostCategoryRuleRuleOrDimensionOutput
	ToGetCostCategoryRuleRuleOrDimensionOutputWithContext(context.Context) GetCostCategoryRuleRuleOrDimensionOutput
}

type GetCostCategoryRuleRuleOrDimensionArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleOrDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleOrDimension)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleOrDimensionArgs) ToGetCostCategoryRuleRuleOrDimensionOutput() GetCostCategoryRuleRuleOrDimensionOutput {
	return i.ToGetCostCategoryRuleRuleOrDimensionOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleOrDimensionArgs) ToGetCostCategoryRuleRuleOrDimensionOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleOrDimensionOutput)
}

// GetCostCategoryRuleRuleOrDimensionArrayInput is an input type that accepts GetCostCategoryRuleRuleOrDimensionArray and GetCostCategoryRuleRuleOrDimensionArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleOrDimensionArrayInput` via:
//
//          GetCostCategoryRuleRuleOrDimensionArray{ GetCostCategoryRuleRuleOrDimensionArgs{...} }
type GetCostCategoryRuleRuleOrDimensionArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleOrDimensionArrayOutput() GetCostCategoryRuleRuleOrDimensionArrayOutput
	ToGetCostCategoryRuleRuleOrDimensionArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleOrDimensionArrayOutput
}

type GetCostCategoryRuleRuleOrDimensionArray []GetCostCategoryRuleRuleOrDimensionInput

func (GetCostCategoryRuleRuleOrDimensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleOrDimension)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleOrDimensionArray) ToGetCostCategoryRuleRuleOrDimensionArrayOutput() GetCostCategoryRuleRuleOrDimensionArrayOutput {
	return i.ToGetCostCategoryRuleRuleOrDimensionArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleOrDimensionArray) ToGetCostCategoryRuleRuleOrDimensionArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrDimensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleOrDimensionArrayOutput)
}

type GetCostCategoryRuleRuleOrDimensionOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleOrDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleOrDimension)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleOrDimensionOutput) ToGetCostCategoryRuleRuleOrDimensionOutput() GetCostCategoryRuleRuleOrDimensionOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrDimensionOutput) ToGetCostCategoryRuleRuleOrDimensionOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrDimensionOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleOrDimensionOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOrDimension) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleOrDimensionOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOrDimension) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleOrDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOrDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleOrDimensionArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleOrDimensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleOrDimension)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleOrDimensionArrayOutput) ToGetCostCategoryRuleRuleOrDimensionArrayOutput() GetCostCategoryRuleRuleOrDimensionArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrDimensionArrayOutput) ToGetCostCategoryRuleRuleOrDimensionArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrDimensionArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrDimensionArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleOrDimensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleOrDimension {
		return vs[0].([]GetCostCategoryRuleRuleOrDimension)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleOrDimensionOutput)
}

type GetCostCategoryRuleRuleOrTag struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleOrTagInput is an input type that accepts GetCostCategoryRuleRuleOrTagArgs and GetCostCategoryRuleRuleOrTagOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleOrTagInput` via:
//
//          GetCostCategoryRuleRuleOrTagArgs{...}
type GetCostCategoryRuleRuleOrTagInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleOrTagOutput() GetCostCategoryRuleRuleOrTagOutput
	ToGetCostCategoryRuleRuleOrTagOutputWithContext(context.Context) GetCostCategoryRuleRuleOrTagOutput
}

type GetCostCategoryRuleRuleOrTagArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleOrTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleOrTag)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleOrTagArgs) ToGetCostCategoryRuleRuleOrTagOutput() GetCostCategoryRuleRuleOrTagOutput {
	return i.ToGetCostCategoryRuleRuleOrTagOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleOrTagArgs) ToGetCostCategoryRuleRuleOrTagOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleOrTagOutput)
}

// GetCostCategoryRuleRuleOrTagArrayInput is an input type that accepts GetCostCategoryRuleRuleOrTagArray and GetCostCategoryRuleRuleOrTagArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleOrTagArrayInput` via:
//
//          GetCostCategoryRuleRuleOrTagArray{ GetCostCategoryRuleRuleOrTagArgs{...} }
type GetCostCategoryRuleRuleOrTagArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleOrTagArrayOutput() GetCostCategoryRuleRuleOrTagArrayOutput
	ToGetCostCategoryRuleRuleOrTagArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleOrTagArrayOutput
}

type GetCostCategoryRuleRuleOrTagArray []GetCostCategoryRuleRuleOrTagInput

func (GetCostCategoryRuleRuleOrTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleOrTag)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleOrTagArray) ToGetCostCategoryRuleRuleOrTagArrayOutput() GetCostCategoryRuleRuleOrTagArrayOutput {
	return i.ToGetCostCategoryRuleRuleOrTagArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleOrTagArray) ToGetCostCategoryRuleRuleOrTagArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleOrTagArrayOutput)
}

type GetCostCategoryRuleRuleOrTagOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleOrTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleOrTag)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleOrTagOutput) ToGetCostCategoryRuleRuleOrTagOutput() GetCostCategoryRuleRuleOrTagOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrTagOutput) ToGetCostCategoryRuleRuleOrTagOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrTagOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleOrTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOrTag) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleOrTagOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOrTag) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleOrTagOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleOrTag) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleOrTagArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleOrTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleOrTag)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleOrTagArrayOutput) ToGetCostCategoryRuleRuleOrTagArrayOutput() GetCostCategoryRuleRuleOrTagArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrTagArrayOutput) ToGetCostCategoryRuleRuleOrTagArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleOrTagArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleOrTagArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleOrTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleOrTag {
		return vs[0].([]GetCostCategoryRuleRuleOrTag)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleOrTagOutput)
}

type GetCostCategoryRuleRuleTag struct {
	// Key for the tag.
	Key string `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions []string `pulumi:"matchOptions"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategoryRuleRuleTagInput is an input type that accepts GetCostCategoryRuleRuleTagArgs and GetCostCategoryRuleRuleTagOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleTagInput` via:
//
//          GetCostCategoryRuleRuleTagArgs{...}
type GetCostCategoryRuleRuleTagInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleTagOutput() GetCostCategoryRuleRuleTagOutput
	ToGetCostCategoryRuleRuleTagOutputWithContext(context.Context) GetCostCategoryRuleRuleTagOutput
}

type GetCostCategoryRuleRuleTagArgs struct {
	// Key for the tag.
	Key pulumi.StringInput `pulumi:"key"`
	// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
	MatchOptions pulumi.StringArrayInput `pulumi:"matchOptions"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategoryRuleRuleTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleTag)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleTagArgs) ToGetCostCategoryRuleRuleTagOutput() GetCostCategoryRuleRuleTagOutput {
	return i.ToGetCostCategoryRuleRuleTagOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleTagArgs) ToGetCostCategoryRuleRuleTagOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleTagOutput)
}

// GetCostCategoryRuleRuleTagArrayInput is an input type that accepts GetCostCategoryRuleRuleTagArray and GetCostCategoryRuleRuleTagArrayOutput values.
// You can construct a concrete instance of `GetCostCategoryRuleRuleTagArrayInput` via:
//
//          GetCostCategoryRuleRuleTagArray{ GetCostCategoryRuleRuleTagArgs{...} }
type GetCostCategoryRuleRuleTagArrayInput interface {
	pulumi.Input

	ToGetCostCategoryRuleRuleTagArrayOutput() GetCostCategoryRuleRuleTagArrayOutput
	ToGetCostCategoryRuleRuleTagArrayOutputWithContext(context.Context) GetCostCategoryRuleRuleTagArrayOutput
}

type GetCostCategoryRuleRuleTagArray []GetCostCategoryRuleRuleTagInput

func (GetCostCategoryRuleRuleTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleTag)(nil)).Elem()
}

func (i GetCostCategoryRuleRuleTagArray) ToGetCostCategoryRuleRuleTagArrayOutput() GetCostCategoryRuleRuleTagArrayOutput {
	return i.ToGetCostCategoryRuleRuleTagArrayOutputWithContext(context.Background())
}

func (i GetCostCategoryRuleRuleTagArray) ToGetCostCategoryRuleRuleTagArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategoryRuleRuleTagArrayOutput)
}

type GetCostCategoryRuleRuleTagOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategoryRuleRuleTag)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleTagOutput) ToGetCostCategoryRuleRuleTagOutput() GetCostCategoryRuleRuleTagOutput {
	return o
}

func (o GetCostCategoryRuleRuleTagOutput) ToGetCostCategoryRuleRuleTagOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleTagOutput {
	return o
}

// Key for the tag.
func (o GetCostCategoryRuleRuleTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleTag) string { return v.Key }).(pulumi.StringOutput)
}

// Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
func (o GetCostCategoryRuleRuleTagOutput) MatchOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleTag) []string { return v.MatchOptions }).(pulumi.StringArrayOutput)
}

// Parameter values.
func (o GetCostCategoryRuleRuleTagOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategoryRuleRuleTag) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategoryRuleRuleTagArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategoryRuleRuleTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategoryRuleRuleTag)(nil)).Elem()
}

func (o GetCostCategoryRuleRuleTagArrayOutput) ToGetCostCategoryRuleRuleTagArrayOutput() GetCostCategoryRuleRuleTagArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleTagArrayOutput) ToGetCostCategoryRuleRuleTagArrayOutputWithContext(ctx context.Context) GetCostCategoryRuleRuleTagArrayOutput {
	return o
}

func (o GetCostCategoryRuleRuleTagArrayOutput) Index(i pulumi.IntInput) GetCostCategoryRuleRuleTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategoryRuleRuleTag {
		return vs[0].([]GetCostCategoryRuleRuleTag)[vs[1].(int)]
	}).(GetCostCategoryRuleRuleTagOutput)
}

type GetCostCategorySplitChargeRule struct {
	// Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
	Method string `pulumi:"method"`
	// Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
	Parameters []GetCostCategorySplitChargeRuleParameter `pulumi:"parameters"`
	// Cost Category value that you want to split.
	Source string `pulumi:"source"`
	// Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
	Targets []string `pulumi:"targets"`
}

// GetCostCategorySplitChargeRuleInput is an input type that accepts GetCostCategorySplitChargeRuleArgs and GetCostCategorySplitChargeRuleOutput values.
// You can construct a concrete instance of `GetCostCategorySplitChargeRuleInput` via:
//
//          GetCostCategorySplitChargeRuleArgs{...}
type GetCostCategorySplitChargeRuleInput interface {
	pulumi.Input

	ToGetCostCategorySplitChargeRuleOutput() GetCostCategorySplitChargeRuleOutput
	ToGetCostCategorySplitChargeRuleOutputWithContext(context.Context) GetCostCategorySplitChargeRuleOutput
}

type GetCostCategorySplitChargeRuleArgs struct {
	// Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
	Method pulumi.StringInput `pulumi:"method"`
	// Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
	Parameters GetCostCategorySplitChargeRuleParameterArrayInput `pulumi:"parameters"`
	// Cost Category value that you want to split.
	Source pulumi.StringInput `pulumi:"source"`
	// Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
	Targets pulumi.StringArrayInput `pulumi:"targets"`
}

func (GetCostCategorySplitChargeRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategorySplitChargeRule)(nil)).Elem()
}

func (i GetCostCategorySplitChargeRuleArgs) ToGetCostCategorySplitChargeRuleOutput() GetCostCategorySplitChargeRuleOutput {
	return i.ToGetCostCategorySplitChargeRuleOutputWithContext(context.Background())
}

func (i GetCostCategorySplitChargeRuleArgs) ToGetCostCategorySplitChargeRuleOutputWithContext(ctx context.Context) GetCostCategorySplitChargeRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategorySplitChargeRuleOutput)
}

// GetCostCategorySplitChargeRuleArrayInput is an input type that accepts GetCostCategorySplitChargeRuleArray and GetCostCategorySplitChargeRuleArrayOutput values.
// You can construct a concrete instance of `GetCostCategorySplitChargeRuleArrayInput` via:
//
//          GetCostCategorySplitChargeRuleArray{ GetCostCategorySplitChargeRuleArgs{...} }
type GetCostCategorySplitChargeRuleArrayInput interface {
	pulumi.Input

	ToGetCostCategorySplitChargeRuleArrayOutput() GetCostCategorySplitChargeRuleArrayOutput
	ToGetCostCategorySplitChargeRuleArrayOutputWithContext(context.Context) GetCostCategorySplitChargeRuleArrayOutput
}

type GetCostCategorySplitChargeRuleArray []GetCostCategorySplitChargeRuleInput

func (GetCostCategorySplitChargeRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategorySplitChargeRule)(nil)).Elem()
}

func (i GetCostCategorySplitChargeRuleArray) ToGetCostCategorySplitChargeRuleArrayOutput() GetCostCategorySplitChargeRuleArrayOutput {
	return i.ToGetCostCategorySplitChargeRuleArrayOutputWithContext(context.Background())
}

func (i GetCostCategorySplitChargeRuleArray) ToGetCostCategorySplitChargeRuleArrayOutputWithContext(ctx context.Context) GetCostCategorySplitChargeRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategorySplitChargeRuleArrayOutput)
}

type GetCostCategorySplitChargeRuleOutput struct{ *pulumi.OutputState }

func (GetCostCategorySplitChargeRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategorySplitChargeRule)(nil)).Elem()
}

func (o GetCostCategorySplitChargeRuleOutput) ToGetCostCategorySplitChargeRuleOutput() GetCostCategorySplitChargeRuleOutput {
	return o
}

func (o GetCostCategorySplitChargeRuleOutput) ToGetCostCategorySplitChargeRuleOutputWithContext(ctx context.Context) GetCostCategorySplitChargeRuleOutput {
	return o
}

// Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
func (o GetCostCategorySplitChargeRuleOutput) Method() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategorySplitChargeRule) string { return v.Method }).(pulumi.StringOutput)
}

// Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
func (o GetCostCategorySplitChargeRuleOutput) Parameters() GetCostCategorySplitChargeRuleParameterArrayOutput {
	return o.ApplyT(func(v GetCostCategorySplitChargeRule) []GetCostCategorySplitChargeRuleParameter { return v.Parameters }).(GetCostCategorySplitChargeRuleParameterArrayOutput)
}

// Cost Category value that you want to split.
func (o GetCostCategorySplitChargeRuleOutput) Source() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategorySplitChargeRule) string { return v.Source }).(pulumi.StringOutput)
}

// Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
func (o GetCostCategorySplitChargeRuleOutput) Targets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategorySplitChargeRule) []string { return v.Targets }).(pulumi.StringArrayOutput)
}

type GetCostCategorySplitChargeRuleArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategorySplitChargeRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategorySplitChargeRule)(nil)).Elem()
}

func (o GetCostCategorySplitChargeRuleArrayOutput) ToGetCostCategorySplitChargeRuleArrayOutput() GetCostCategorySplitChargeRuleArrayOutput {
	return o
}

func (o GetCostCategorySplitChargeRuleArrayOutput) ToGetCostCategorySplitChargeRuleArrayOutputWithContext(ctx context.Context) GetCostCategorySplitChargeRuleArrayOutput {
	return o
}

func (o GetCostCategorySplitChargeRuleArrayOutput) Index(i pulumi.IntInput) GetCostCategorySplitChargeRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategorySplitChargeRule {
		return vs[0].([]GetCostCategorySplitChargeRule)[vs[1].(int)]
	}).(GetCostCategorySplitChargeRuleOutput)
}

type GetCostCategorySplitChargeRuleParameter struct {
	// Parameter type.
	Type string `pulumi:"type"`
	// Parameter values.
	Values []string `pulumi:"values"`
}

// GetCostCategorySplitChargeRuleParameterInput is an input type that accepts GetCostCategorySplitChargeRuleParameterArgs and GetCostCategorySplitChargeRuleParameterOutput values.
// You can construct a concrete instance of `GetCostCategorySplitChargeRuleParameterInput` via:
//
//          GetCostCategorySplitChargeRuleParameterArgs{...}
type GetCostCategorySplitChargeRuleParameterInput interface {
	pulumi.Input

	ToGetCostCategorySplitChargeRuleParameterOutput() GetCostCategorySplitChargeRuleParameterOutput
	ToGetCostCategorySplitChargeRuleParameterOutputWithContext(context.Context) GetCostCategorySplitChargeRuleParameterOutput
}

type GetCostCategorySplitChargeRuleParameterArgs struct {
	// Parameter type.
	Type pulumi.StringInput `pulumi:"type"`
	// Parameter values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GetCostCategorySplitChargeRuleParameterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategorySplitChargeRuleParameter)(nil)).Elem()
}

func (i GetCostCategorySplitChargeRuleParameterArgs) ToGetCostCategorySplitChargeRuleParameterOutput() GetCostCategorySplitChargeRuleParameterOutput {
	return i.ToGetCostCategorySplitChargeRuleParameterOutputWithContext(context.Background())
}

func (i GetCostCategorySplitChargeRuleParameterArgs) ToGetCostCategorySplitChargeRuleParameterOutputWithContext(ctx context.Context) GetCostCategorySplitChargeRuleParameterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategorySplitChargeRuleParameterOutput)
}

// GetCostCategorySplitChargeRuleParameterArrayInput is an input type that accepts GetCostCategorySplitChargeRuleParameterArray and GetCostCategorySplitChargeRuleParameterArrayOutput values.
// You can construct a concrete instance of `GetCostCategorySplitChargeRuleParameterArrayInput` via:
//
//          GetCostCategorySplitChargeRuleParameterArray{ GetCostCategorySplitChargeRuleParameterArgs{...} }
type GetCostCategorySplitChargeRuleParameterArrayInput interface {
	pulumi.Input

	ToGetCostCategorySplitChargeRuleParameterArrayOutput() GetCostCategorySplitChargeRuleParameterArrayOutput
	ToGetCostCategorySplitChargeRuleParameterArrayOutputWithContext(context.Context) GetCostCategorySplitChargeRuleParameterArrayOutput
}

type GetCostCategorySplitChargeRuleParameterArray []GetCostCategorySplitChargeRuleParameterInput

func (GetCostCategorySplitChargeRuleParameterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategorySplitChargeRuleParameter)(nil)).Elem()
}

func (i GetCostCategorySplitChargeRuleParameterArray) ToGetCostCategorySplitChargeRuleParameterArrayOutput() GetCostCategorySplitChargeRuleParameterArrayOutput {
	return i.ToGetCostCategorySplitChargeRuleParameterArrayOutputWithContext(context.Background())
}

func (i GetCostCategorySplitChargeRuleParameterArray) ToGetCostCategorySplitChargeRuleParameterArrayOutputWithContext(ctx context.Context) GetCostCategorySplitChargeRuleParameterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCostCategorySplitChargeRuleParameterArrayOutput)
}

type GetCostCategorySplitChargeRuleParameterOutput struct{ *pulumi.OutputState }

func (GetCostCategorySplitChargeRuleParameterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCostCategorySplitChargeRuleParameter)(nil)).Elem()
}

func (o GetCostCategorySplitChargeRuleParameterOutput) ToGetCostCategorySplitChargeRuleParameterOutput() GetCostCategorySplitChargeRuleParameterOutput {
	return o
}

func (o GetCostCategorySplitChargeRuleParameterOutput) ToGetCostCategorySplitChargeRuleParameterOutputWithContext(ctx context.Context) GetCostCategorySplitChargeRuleParameterOutput {
	return o
}

// Parameter type.
func (o GetCostCategorySplitChargeRuleParameterOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GetCostCategorySplitChargeRuleParameter) string { return v.Type }).(pulumi.StringOutput)
}

// Parameter values.
func (o GetCostCategorySplitChargeRuleParameterOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCostCategorySplitChargeRuleParameter) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GetCostCategorySplitChargeRuleParameterArrayOutput struct{ *pulumi.OutputState }

func (GetCostCategorySplitChargeRuleParameterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCostCategorySplitChargeRuleParameter)(nil)).Elem()
}

func (o GetCostCategorySplitChargeRuleParameterArrayOutput) ToGetCostCategorySplitChargeRuleParameterArrayOutput() GetCostCategorySplitChargeRuleParameterArrayOutput {
	return o
}

func (o GetCostCategorySplitChargeRuleParameterArrayOutput) ToGetCostCategorySplitChargeRuleParameterArrayOutputWithContext(ctx context.Context) GetCostCategorySplitChargeRuleParameterArrayOutput {
	return o
}

func (o GetCostCategorySplitChargeRuleParameterArrayOutput) Index(i pulumi.IntInput) GetCostCategorySplitChargeRuleParameterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCostCategorySplitChargeRuleParameter {
		return vs[0].([]GetCostCategorySplitChargeRuleParameter)[vs[1].(int)]
	}).(GetCostCategorySplitChargeRuleParameterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleInput)(nil)).Elem(), CostCategoryRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleArrayInput)(nil)).Elem(), CostCategoryRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleInheritedValueInput)(nil)).Elem(), CostCategoryRuleInheritedValueArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleInheritedValuePtrInput)(nil)).Elem(), CostCategoryRuleInheritedValueArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleInput)(nil)).Elem(), CostCategoryRuleRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRulePtrInput)(nil)).Elem(), CostCategoryRuleRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleAndInput)(nil)).Elem(), CostCategoryRuleRuleAndArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleAndArrayInput)(nil)).Elem(), CostCategoryRuleRuleAndArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleAndCostCategoryInput)(nil)).Elem(), CostCategoryRuleRuleAndCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleAndCostCategoryPtrInput)(nil)).Elem(), CostCategoryRuleRuleAndCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleAndDimensionInput)(nil)).Elem(), CostCategoryRuleRuleAndDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleAndDimensionPtrInput)(nil)).Elem(), CostCategoryRuleRuleAndDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleAndTagsInput)(nil)).Elem(), CostCategoryRuleRuleAndTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleAndTagsPtrInput)(nil)).Elem(), CostCategoryRuleRuleAndTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleCostCategoryInput)(nil)).Elem(), CostCategoryRuleRuleCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleCostCategoryPtrInput)(nil)).Elem(), CostCategoryRuleRuleCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleDimensionInput)(nil)).Elem(), CostCategoryRuleRuleDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleDimensionPtrInput)(nil)).Elem(), CostCategoryRuleRuleDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleNotInput)(nil)).Elem(), CostCategoryRuleRuleNotArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleNotPtrInput)(nil)).Elem(), CostCategoryRuleRuleNotArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleNotCostCategoryInput)(nil)).Elem(), CostCategoryRuleRuleNotCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleNotCostCategoryPtrInput)(nil)).Elem(), CostCategoryRuleRuleNotCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleNotDimensionInput)(nil)).Elem(), CostCategoryRuleRuleNotDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleNotDimensionPtrInput)(nil)).Elem(), CostCategoryRuleRuleNotDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleNotTagsInput)(nil)).Elem(), CostCategoryRuleRuleNotTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleNotTagsPtrInput)(nil)).Elem(), CostCategoryRuleRuleNotTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleOrInput)(nil)).Elem(), CostCategoryRuleRuleOrArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleOrArrayInput)(nil)).Elem(), CostCategoryRuleRuleOrArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleOrCostCategoryInput)(nil)).Elem(), CostCategoryRuleRuleOrCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleOrCostCategoryPtrInput)(nil)).Elem(), CostCategoryRuleRuleOrCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleOrDimensionInput)(nil)).Elem(), CostCategoryRuleRuleOrDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleOrDimensionPtrInput)(nil)).Elem(), CostCategoryRuleRuleOrDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleOrTagsInput)(nil)).Elem(), CostCategoryRuleRuleOrTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleOrTagsPtrInput)(nil)).Elem(), CostCategoryRuleRuleOrTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleTagsInput)(nil)).Elem(), CostCategoryRuleRuleTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategoryRuleRuleTagsPtrInput)(nil)).Elem(), CostCategoryRuleRuleTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategorySplitChargeRuleInput)(nil)).Elem(), CostCategorySplitChargeRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategorySplitChargeRuleArrayInput)(nil)).Elem(), CostCategorySplitChargeRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategorySplitChargeRuleParameterInput)(nil)).Elem(), CostCategorySplitChargeRuleParameterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CostCategorySplitChargeRuleParameterArrayInput)(nil)).Elem(), CostCategorySplitChargeRuleParameterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterInput)(nil)).Elem(), TagsFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterPtrInput)(nil)).Elem(), TagsFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterAndInput)(nil)).Elem(), TagsFilterAndArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterAndArrayInput)(nil)).Elem(), TagsFilterAndArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterAndCostCategoryInput)(nil)).Elem(), TagsFilterAndCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterAndCostCategoryPtrInput)(nil)).Elem(), TagsFilterAndCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterAndDimensionInput)(nil)).Elem(), TagsFilterAndDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterAndDimensionPtrInput)(nil)).Elem(), TagsFilterAndDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterAndTagsInput)(nil)).Elem(), TagsFilterAndTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterAndTagsPtrInput)(nil)).Elem(), TagsFilterAndTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterCostCategoryInput)(nil)).Elem(), TagsFilterCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterCostCategoryPtrInput)(nil)).Elem(), TagsFilterCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterDimensionInput)(nil)).Elem(), TagsFilterDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterDimensionPtrInput)(nil)).Elem(), TagsFilterDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterNotInput)(nil)).Elem(), TagsFilterNotArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterNotPtrInput)(nil)).Elem(), TagsFilterNotArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterNotCostCategoryInput)(nil)).Elem(), TagsFilterNotCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterNotCostCategoryPtrInput)(nil)).Elem(), TagsFilterNotCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterNotDimensionInput)(nil)).Elem(), TagsFilterNotDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterNotDimensionPtrInput)(nil)).Elem(), TagsFilterNotDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterNotTagsInput)(nil)).Elem(), TagsFilterNotTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterNotTagsPtrInput)(nil)).Elem(), TagsFilterNotTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterOrInput)(nil)).Elem(), TagsFilterOrArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterOrArrayInput)(nil)).Elem(), TagsFilterOrArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterOrCostCategoryInput)(nil)).Elem(), TagsFilterOrCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterOrCostCategoryPtrInput)(nil)).Elem(), TagsFilterOrCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterOrDimensionInput)(nil)).Elem(), TagsFilterOrDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterOrDimensionPtrInput)(nil)).Elem(), TagsFilterOrDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterOrTagsInput)(nil)).Elem(), TagsFilterOrTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterOrTagsPtrInput)(nil)).Elem(), TagsFilterOrTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterTagsInput)(nil)).Elem(), TagsFilterTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsFilterTagsPtrInput)(nil)).Elem(), TagsFilterTagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsSortByInput)(nil)).Elem(), TagsSortByArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsSortByArrayInput)(nil)).Elem(), TagsSortByArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsTimePeriodInput)(nil)).Elem(), TagsTimePeriodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleInput)(nil)).Elem(), GetCostCategoryRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleArrayInput)(nil)).Elem(), GetCostCategoryRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleInheritedValueInput)(nil)).Elem(), GetCostCategoryRuleInheritedValueArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleInheritedValueArrayInput)(nil)).Elem(), GetCostCategoryRuleInheritedValueArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleInput)(nil)).Elem(), GetCostCategoryRuleRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleAndInput)(nil)).Elem(), GetCostCategoryRuleRuleAndArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleAndArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleAndArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleAndCostCategoryInput)(nil)).Elem(), GetCostCategoryRuleRuleAndCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleAndCostCategoryArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleAndCostCategoryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleAndDimensionInput)(nil)).Elem(), GetCostCategoryRuleRuleAndDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleAndDimensionArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleAndDimensionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleAndTagInput)(nil)).Elem(), GetCostCategoryRuleRuleAndTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleAndTagArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleAndTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleCostCategoryInput)(nil)).Elem(), GetCostCategoryRuleRuleCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleCostCategoryArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleCostCategoryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleDimensionInput)(nil)).Elem(), GetCostCategoryRuleRuleDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleDimensionArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleDimensionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleNotInput)(nil)).Elem(), GetCostCategoryRuleRuleNotArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleNotArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleNotArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleNotCostCategoryInput)(nil)).Elem(), GetCostCategoryRuleRuleNotCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleNotCostCategoryArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleNotCostCategoryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleNotDimensionInput)(nil)).Elem(), GetCostCategoryRuleRuleNotDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleNotDimensionArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleNotDimensionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleNotTagInput)(nil)).Elem(), GetCostCategoryRuleRuleNotTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleNotTagArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleNotTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleOrInput)(nil)).Elem(), GetCostCategoryRuleRuleOrArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleOrArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleOrArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleOrCostCategoryInput)(nil)).Elem(), GetCostCategoryRuleRuleOrCostCategoryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleOrCostCategoryArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleOrCostCategoryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleOrDimensionInput)(nil)).Elem(), GetCostCategoryRuleRuleOrDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleOrDimensionArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleOrDimensionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleOrTagInput)(nil)).Elem(), GetCostCategoryRuleRuleOrTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleOrTagArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleOrTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleTagInput)(nil)).Elem(), GetCostCategoryRuleRuleTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategoryRuleRuleTagArrayInput)(nil)).Elem(), GetCostCategoryRuleRuleTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategorySplitChargeRuleInput)(nil)).Elem(), GetCostCategorySplitChargeRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategorySplitChargeRuleArrayInput)(nil)).Elem(), GetCostCategorySplitChargeRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategorySplitChargeRuleParameterInput)(nil)).Elem(), GetCostCategorySplitChargeRuleParameterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCostCategorySplitChargeRuleParameterArrayInput)(nil)).Elem(), GetCostCategorySplitChargeRuleParameterArray{})
	pulumi.RegisterOutputType(CostCategoryRuleOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleArrayOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleInheritedValueOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleInheritedValuePtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRulePtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleAndOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleAndArrayOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleAndCostCategoryOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleAndCostCategoryPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleAndDimensionOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleAndDimensionPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleAndTagsOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleAndTagsPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleCostCategoryOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleCostCategoryPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleDimensionOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleDimensionPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleNotOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleNotPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleNotCostCategoryOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleNotCostCategoryPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleNotDimensionOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleNotDimensionPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleNotTagsOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleNotTagsPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleOrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleOrArrayOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleOrCostCategoryOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleOrCostCategoryPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleOrDimensionOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleOrDimensionPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleOrTagsOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleOrTagsPtrOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleTagsOutput{})
	pulumi.RegisterOutputType(CostCategoryRuleRuleTagsPtrOutput{})
	pulumi.RegisterOutputType(CostCategorySplitChargeRuleOutput{})
	pulumi.RegisterOutputType(CostCategorySplitChargeRuleArrayOutput{})
	pulumi.RegisterOutputType(CostCategorySplitChargeRuleParameterOutput{})
	pulumi.RegisterOutputType(CostCategorySplitChargeRuleParameterArrayOutput{})
	pulumi.RegisterOutputType(TagsFilterOutput{})
	pulumi.RegisterOutputType(TagsFilterPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterAndOutput{})
	pulumi.RegisterOutputType(TagsFilterAndArrayOutput{})
	pulumi.RegisterOutputType(TagsFilterAndCostCategoryOutput{})
	pulumi.RegisterOutputType(TagsFilterAndCostCategoryPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterAndDimensionOutput{})
	pulumi.RegisterOutputType(TagsFilterAndDimensionPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterAndTagsOutput{})
	pulumi.RegisterOutputType(TagsFilterAndTagsPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterCostCategoryOutput{})
	pulumi.RegisterOutputType(TagsFilterCostCategoryPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterDimensionOutput{})
	pulumi.RegisterOutputType(TagsFilterDimensionPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterNotOutput{})
	pulumi.RegisterOutputType(TagsFilterNotPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterNotCostCategoryOutput{})
	pulumi.RegisterOutputType(TagsFilterNotCostCategoryPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterNotDimensionOutput{})
	pulumi.RegisterOutputType(TagsFilterNotDimensionPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterNotTagsOutput{})
	pulumi.RegisterOutputType(TagsFilterNotTagsPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterOrOutput{})
	pulumi.RegisterOutputType(TagsFilterOrArrayOutput{})
	pulumi.RegisterOutputType(TagsFilterOrCostCategoryOutput{})
	pulumi.RegisterOutputType(TagsFilterOrCostCategoryPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterOrDimensionOutput{})
	pulumi.RegisterOutputType(TagsFilterOrDimensionPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterOrTagsOutput{})
	pulumi.RegisterOutputType(TagsFilterOrTagsPtrOutput{})
	pulumi.RegisterOutputType(TagsFilterTagsOutput{})
	pulumi.RegisterOutputType(TagsFilterTagsPtrOutput{})
	pulumi.RegisterOutputType(TagsSortByOutput{})
	pulumi.RegisterOutputType(TagsSortByArrayOutput{})
	pulumi.RegisterOutputType(TagsTimePeriodOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleInheritedValueOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleInheritedValueArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleAndOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleAndArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleAndCostCategoryOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleAndCostCategoryArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleAndDimensionOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleAndDimensionArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleAndTagOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleAndTagArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleCostCategoryOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleCostCategoryArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleDimensionOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleDimensionArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleNotOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleNotArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleNotCostCategoryOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleNotCostCategoryArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleNotDimensionOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleNotDimensionArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleNotTagOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleNotTagArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleOrOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleOrArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleOrCostCategoryOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleOrCostCategoryArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleOrDimensionOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleOrDimensionArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleOrTagOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleOrTagArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleTagOutput{})
	pulumi.RegisterOutputType(GetCostCategoryRuleRuleTagArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategorySplitChargeRuleOutput{})
	pulumi.RegisterOutputType(GetCostCategorySplitChargeRuleArrayOutput{})
	pulumi.RegisterOutputType(GetCostCategorySplitChargeRuleParameterOutput{})
	pulumi.RegisterOutputType(GetCostCategorySplitChargeRuleParameterArrayOutput{})
}
