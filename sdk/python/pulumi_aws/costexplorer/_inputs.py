# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'CostCategoryRuleArgs',
    'CostCategoryRuleInheritedValueArgs',
    'CostCategoryRuleRuleArgs',
    'CostCategoryRuleRuleAndArgs',
    'CostCategoryRuleRuleAndCostCategoryArgs',
    'CostCategoryRuleRuleAndDimensionArgs',
    'CostCategoryRuleRuleAndTagsArgs',
    'CostCategoryRuleRuleCostCategoryArgs',
    'CostCategoryRuleRuleDimensionArgs',
    'CostCategoryRuleRuleNotArgs',
    'CostCategoryRuleRuleNotCostCategoryArgs',
    'CostCategoryRuleRuleNotDimensionArgs',
    'CostCategoryRuleRuleNotTagsArgs',
    'CostCategoryRuleRuleOrArgs',
    'CostCategoryRuleRuleOrCostCategoryArgs',
    'CostCategoryRuleRuleOrDimensionArgs',
    'CostCategoryRuleRuleOrTagsArgs',
    'CostCategoryRuleRuleTagsArgs',
    'CostCategorySplitChargeRuleArgs',
    'CostCategorySplitChargeRuleParameterArgs',
    'TagsFilterArgs',
    'TagsFilterAndArgs',
    'TagsFilterAndCostCategoryArgs',
    'TagsFilterAndDimensionArgs',
    'TagsFilterAndTagsArgs',
    'TagsFilterCostCategoryArgs',
    'TagsFilterDimensionArgs',
    'TagsFilterNotArgs',
    'TagsFilterNotCostCategoryArgs',
    'TagsFilterNotDimensionArgs',
    'TagsFilterNotTagsArgs',
    'TagsFilterOrArgs',
    'TagsFilterOrCostCategoryArgs',
    'TagsFilterOrDimensionArgs',
    'TagsFilterOrTagsArgs',
    'TagsFilterTagsArgs',
    'TagsSortByArgs',
    'TagsTimePeriodArgs',
]

@pulumi.input_type
class CostCategoryRuleArgs:
    def __init__(__self__, *,
                 inherited_value: Optional[pulumi.Input['CostCategoryRuleInheritedValueArgs']] = None,
                 rule: Optional[pulumi.Input['CostCategoryRuleRuleArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['CostCategoryRuleInheritedValueArgs'] inherited_value: Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        :param pulumi.Input['CostCategoryRuleRuleArgs'] rule: Configuration block for the `Expression` object used to categorize costs. See below.
        :param pulumi.Input[str] type: Parameter type.
        :param pulumi.Input[str] value: Default value for the cost category.
        """
        if inherited_value is not None:
            pulumi.set(__self__, "inherited_value", inherited_value)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inheritedValue")
    def inherited_value(self) -> Optional[pulumi.Input['CostCategoryRuleInheritedValueArgs']]:
        """
        Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        """
        return pulumi.get(self, "inherited_value")

    @inherited_value.setter
    def inherited_value(self, value: Optional[pulumi.Input['CostCategoryRuleInheritedValueArgs']]):
        pulumi.set(self, "inherited_value", value)

    @property
    @pulumi.getter
    def rule(self) -> Optional[pulumi.Input['CostCategoryRuleRuleArgs']]:
        """
        Configuration block for the `Expression` object used to categorize costs. See below.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input['CostCategoryRuleRuleArgs']]):
        pulumi.set(self, "rule", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Default value for the cost category.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CostCategoryRuleInheritedValueArgs:
    def __init__(__self__, *,
                 dimension_key: Optional[pulumi.Input[str]] = None,
                 dimension_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dimension_key: Key to extract cost category values.
        :param pulumi.Input[str] dimension_name: Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        if dimension_key is not None:
            pulumi.set(__self__, "dimension_key", dimension_key)
        if dimension_name is not None:
            pulumi.set(__self__, "dimension_name", dimension_name)

    @property
    @pulumi.getter(name="dimensionKey")
    def dimension_key(self) -> Optional[pulumi.Input[str]]:
        """
        Key to extract cost category values.
        """
        return pulumi.get(self, "dimension_key")

    @dimension_key.setter
    def dimension_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dimension_key", value)

    @property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        return pulumi.get(self, "dimension_name")

    @dimension_name.setter
    def dimension_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dimension_name", value)


@pulumi.input_type
class CostCategoryRuleRuleArgs:
    def __init__(__self__, *,
                 ands: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgs']]]] = None,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleDimensionArgs']] = None,
                 not_: Optional[pulumi.Input['CostCategoryRuleRuleNotArgs']] = None,
                 ors: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgs']]]] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleTagsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgs']]] ands: Return results that match both `Dimension` objects.
        :param pulumi.Input['CostCategoryRuleRuleCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleNotArgs'] not_: Return results that match both `Dimension` object.
        :param pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgs']]] ors: Return results that match both `Dimension` object.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgs']]]]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgs']]]]):
        pulumi.set(self, "ands", value)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotArgs']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotArgs']]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def ors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgs']]]]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgs']]]]):
        pulumi.set(self, "ors", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleTagsArgs']]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class CostCategoryRuleRuleAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleAndDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleAndTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleAndDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndTagsArgs']]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class CostCategoryRuleRuleAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategoryRuleRuleAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategoryRuleRuleAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategoryRuleRuleCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategoryRuleRuleDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategoryRuleRuleNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleNotDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleNotTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleNotDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotTagsArgs']]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class CostCategoryRuleRuleNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategoryRuleRuleNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategoryRuleRuleNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategoryRuleRuleOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleOrDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleOrTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleOrDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrTagsArgs']]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class CostCategoryRuleRuleOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategoryRuleRuleOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategoryRuleRuleOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategoryRuleRuleTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CostCategorySplitChargeRuleArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 source: pulumi.Input[str],
                 targets: pulumi.Input[Sequence[pulumi.Input[str]]],
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] method: Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        :param pulumi.Input[str] source: Cost Category value that you want to split.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] targets: Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        :param pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgs']]] parameters: Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "targets", targets)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Cost Category value that you want to split.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgs']]]]:
        """
        Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class CostCategorySplitChargeRuleParameterArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: Parameter type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterArgs:
    def __init__(__self__, *,
                 ands: Optional[Sequence['TagsFilterAndArgs']] = None,
                 cost_category: Optional['TagsFilterCostCategoryArgs'] = None,
                 dimension: Optional['TagsFilterDimensionArgs'] = None,
                 not_: Optional['TagsFilterNotArgs'] = None,
                 ors: Optional[Sequence['TagsFilterOrArgs']] = None,
                 tags: Optional['TagsFilterTagsArgs'] = None):
        """
        :param Sequence['TagsFilterAndArgs'] ands: Return results that match both `Dimension` objects.
        :param 'TagsFilterCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'TagsFilterDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'TagsFilterNotArgs' not_: Return results that match both `Dimension` object.
        :param Sequence['TagsFilterOrArgs'] ors: Return results that match both `Dimension` object.
        :param 'TagsFilterTagsArgs' tags: Tags that match your request.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['TagsFilterAndArgs']]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[Sequence['TagsFilterAndArgs']]):
        pulumi.set(self, "ands", value)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['TagsFilterCostCategoryArgs']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['TagsFilterCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional['TagsFilterDimensionArgs']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['TagsFilterDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['TagsFilterNotArgs']:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional['TagsFilterNotArgs']):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['TagsFilterOrArgs']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[Sequence['TagsFilterOrArgs']]):
        pulumi.set(self, "ors", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional['TagsFilterTagsArgs']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['TagsFilterTagsArgs']):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class TagsFilterAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional['TagsFilterAndCostCategoryArgs'] = None,
                 dimension: Optional['TagsFilterAndDimensionArgs'] = None,
                 tags: Optional['TagsFilterAndTagsArgs'] = None):
        """
        :param 'TagsFilterAndCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'TagsFilterAndDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'TagsFilterAndTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['TagsFilterAndCostCategoryArgs']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['TagsFilterAndCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional['TagsFilterAndDimensionArgs']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['TagsFilterAndDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional['TagsFilterAndTagsArgs']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['TagsFilterAndTagsArgs']):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class TagsFilterAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional['TagsFilterNotCostCategoryArgs'] = None,
                 dimension: Optional['TagsFilterNotDimensionArgs'] = None,
                 tags: Optional['TagsFilterNotTagsArgs'] = None):
        """
        :param 'TagsFilterNotCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'TagsFilterNotDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'TagsFilterNotTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['TagsFilterNotCostCategoryArgs']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['TagsFilterNotCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional['TagsFilterNotDimensionArgs']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['TagsFilterNotDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional['TagsFilterNotTagsArgs']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['TagsFilterNotTagsArgs']):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class TagsFilterNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional['TagsFilterOrCostCategoryArgs'] = None,
                 dimension: Optional['TagsFilterOrDimensionArgs'] = None,
                 tags: Optional['TagsFilterOrTagsArgs'] = None):
        """
        :param 'TagsFilterOrCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'TagsFilterOrDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'TagsFilterOrTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['TagsFilterOrCostCategoryArgs']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['TagsFilterOrCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional['TagsFilterOrDimensionArgs']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['TagsFilterOrDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional['TagsFilterOrTagsArgs']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['TagsFilterOrTagsArgs']):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class TagsFilterOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsFilterTagsArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagsSortByArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 sort_order: Optional[str] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param str sort_order: order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if sort_order is not None:
            pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> Optional[str]:
        """
        order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
        """
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: Optional[str]):
        pulumi.set(self, "sort_order", value)


@pulumi.input_type
class TagsTimePeriodArgs:
    def __init__(__self__, *,
                 end: str,
                 start: str):
        """
        :param str end: Beginning of the time period.
        :param str start: End of the time period.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        Beginning of the time period.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: str):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        End of the time period.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: str):
        pulumi.set(self, "start", value)


